; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\Output_App\hostcomm.o --asm_dir=..\Output_App\ --list_dir=..\Output_App\ --depend=..\Output_App\hostcomm.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=870 -I.\System\CM3 -I.\System\FWlib\inc -I.\System\Startup -I.\ISR -I.\Main -I.\Management\DisplayDriver -I.\Management\HumanInput -I.\Management\Interface -I.\Management\RotationMotor -I.\Management\ScanMotor -I.\Management\Common_CRC -I.\Management\QRCode -I.\Management\SystemManage_RTC -I.\Management\SignalProcess_Sample -I.\USB -I.\USB\comm -I.\USB\lib -I.\USB\src -I.\USB\USB_Communication -ID:\Keil4.0\ARM\RV31\Inc -ID:\Keil4.0\ARM\CMSIS\Include -ID:\Keil4.0\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DUSE_STM3210E_EVAL -W --omf_browse=..\Output_App\hostcomm.crf USB\USB_Communication\HostComm.c]
                          THUMB

                          AREA ||i.HiByte||, CODE, READONLY, ALIGN=1

                  HiByte PROC
;;;281    /******************************************************************************/
;;;282    static uint8 HiByte(uint16 value)
000000  4601              MOV      r1,r0
;;;283    {
;;;284    	return (uint8)((value & 0xFF00) >> 8);
000002  0a08              LSRS     r0,r1,#8
;;;285    }
000004  4770              BX       lr
;;;286    
                          ENDP


                          AREA ||i.HostComm_Cmd_Process||, CODE, READONLY, ALIGN=2

                  HostComm_Cmd_Process PROC
;;;173    /******************************************************************************/
;;;174    uint8 HostComm_Cmd_Process(void)
000000  b570              PUSH     {r4-r6,lr}
;;;175    {
;;;176    	uint16 responseLength = 0;
000002  2400              MOVS     r4,#0
;;;177    	uint8 rc = 0;
000004  2500              MOVS     r5,#0
;;;178    
;;;179    	/* Command type */
;;;180    	cmdType = cmdBuffer[OFFSET_CMD_TYPE_RX];
000006  483f              LDR      r0,|L2.260|
000008  7800              LDRB     r0,[r0,#0]  ; cmdBuffer
00000a  493f              LDR      r1,|L2.264|
00000c  7008              STRB     r0,[r1,#0]
;;;181    	/* Command code */
;;;182    	cmdCode = cmdBuffer[OFFSET_CMD_CODE_RX];
00000e  483d              LDR      r0,|L2.260|
000010  7840              LDRB     r0,[r0,#1]  ; cmdBuffer
000012  493e              LDR      r1,|L2.268|
000014  7008              STRB     r0,[r1,#0]
;;;183    
;;;184    	if (cmdType == CMD_TYPE_APP)
000016  483c              LDR      r0,|L2.264|
000018  7800              LDRB     r0,[r0,#0]  ; cmdType
00001a  28fe              CMP      r0,#0xfe
00001c  d15a              BNE      |L2.212|
;;;185    	{
;;;186    		switch (cmdCode)
00001e  4608              MOV      r0,r1
000020  7800              LDRB     r0,[r0,#0]  ; cmdCode
000022  3810              SUBS     r0,r0,#0x10
000024  2819              CMP      r0,#0x19
000026  d24e              BCS      |L2.198|
000028  e8dff000          TBB      [pc,r0]
00002c  0d111519          DCB      0x0d,0x11,0x15,0x19
000030  1d212529          DCB      0x1d,0x21,0x25,0x29
000034  2d314145          DCB      0x2d,0x31,0x41,0x45
000038  4d4d4d4d          DCB      0x4d,0x4d,0x4d,0x4d
00003c  4d493539          DCB      0x4d,0x49,0x35,0x39
000040  4d4d4d4d          DCB      0x4d,0x4d,0x4d,0x4d
000044  3d00              DCB      0x3d,0x00
;;;187    		{
;;;188    		case CMD_CODE_APP_SYSINFO:
;;;189    			responseLength = HostComm_Cmd_Respond_APP_SysInfo();
000046  f7fffffe          BL       HostComm_Cmd_Respond_APP_SysInfo
00004a  4604              MOV      r4,r0
;;;190    			break;
00004c  e041              B        |L2.210|
;;;191    		case CMD_CODE_APP_LAUNCH_BL:
;;;192    			responseLength = HostComm_Cmd_Respond_APP_LaunchBL();
00004e  f7fffffe          BL       HostComm_Cmd_Respond_APP_LaunchBL
000052  4604              MOV      r4,r0
;;;193    			break;
000054  e03d              B        |L2.210|
;;;194    		case CMD_CODE_APP_READ_IDCARD:
;;;195    			responseLength = HostComm_Cmd_Respond_APP_ReadIDCard();
000056  f7fffffe          BL       HostComm_Cmd_Respond_APP_ReadIDCard
00005a  4604              MOV      r4,r0
;;;196    			break;
00005c  e039              B        |L2.210|
;;;197    		case CMD_CODE_APP_WRITE_IDCARD:
;;;198    			responseLength = HostComm_Cmd_Respond_APP_WriteIDCard();
00005e  f7fffffe          BL       HostComm_Cmd_Respond_APP_WriteIDCard
000062  4604              MOV      r4,r0
;;;199    			break;
000064  e035              B        |L2.210|
;;;200    		case CMD_CODE_APP_SET_TIME:
;;;201    			responseLength = HostComm_Cmd_Respond_APP_SetTime();
000066  f7fffffe          BL       HostComm_Cmd_Respond_APP_SetTime
00006a  4604              MOV      r4,r0
;;;202    			break;
00006c  e031              B        |L2.210|
;;;203    		case CMD_CODE_APP_SET_MODE:
;;;204    			responseLength = HostComm_Cmd_Respond_APP_SetMode();
00006e  f7fffffe          BL       HostComm_Cmd_Respond_APP_SetMode
000072  4604              MOV      r4,r0
;;;205    			break;
000074  e02d              B        |L2.210|
;;;206    		case CMD_CODE_APP_SET_MFG:
;;;207    			responseLength = HostComm_Cmd_Respond_APP_SetMFG();
000076  f7fffffe          BL       HostComm_Cmd_Respond_APP_SetMFG
00007a  4604              MOV      r4,r0
;;;208    			break;
00007c  e029              B        |L2.210|
;;;209    		case CMD_CODE_APP_SET_LANGUAGE:
;;;210    			responseLength = HostComm_Cmd_Respond_APP_SetLanguage();
00007e  f7fffffe          BL       HostComm_Cmd_Respond_APP_SetLanguage
000082  4604              MOV      r4,r0
;;;211    			break;
000084  e025              B        |L2.210|
;;;212    		case CMD_CODE_APP_SET_PRINTER:
;;;213    			responseLength = HostComm_Cmd_Respond_APP_SetPrinter();
000086  f7fffffe          BL       HostComm_Cmd_Respond_APP_SetPrinter
00008a  4604              MOV      r4,r0
;;;214    			break;
00008c  e021              B        |L2.210|
;;;215    		case CMD_CODE_APP_SET_OUT_FAB:
;;;216    			responseLength = HostComm_Cmd_Respond_APP_SetOutFab();
00008e  f7fffffe          BL       HostComm_Cmd_Respond_APP_SetOutFab
000092  4604              MOV      r4,r0
;;;217    			break;
000094  e01d              B        |L2.210|
;;;218    		case CMD_CODE_APP_READ_RESISTOR:
;;;219    			responseLength = HostComm_Cmd_Respond_APP_ReadResistor();
000096  f7fffffe          BL       HostComm_Cmd_Respond_APP_ReadResistor
00009a  4604              MOV      r4,r0
;;;220    			break;
00009c  e019              B        |L2.210|
;;;221    		case CMD_CODE_APP_WRITE_RESISTOR:
;;;222    			responseLength = HostComm_Cmd_Respond_APP_WriteResistor();
00009e  f7fffffe          BL       HostComm_Cmd_Respond_APP_WriteResistor
0000a2  4604              MOV      r4,r0
;;;223    			break;
0000a4  e015              B        |L2.210|
;;;224    		case CMD_CODE_APP_SET_CALC_PARAMETERS:
;;;225    			responseLength = HostComm_Cmd_Respond_APP_SetCalcParameters();
0000a6  f7fffffe          BL       HostComm_Cmd_Respond_APP_SetCalcParameters
0000aa  4604              MOV      r4,r0
;;;226    			break;
0000ac  e011              B        |L2.210|
;;;227    #if !RL_A3000
;;;228    		case CMD_CODE_APP_START_STOP_READ_RECORD:
;;;229    			responseLength = HostComm_Cmd_Respond_APP_StartStop_ReadRecords();
0000ae  f7fffffe          BL       HostComm_Cmd_Respond_APP_StartStop_ReadRecords
0000b2  4604              MOV      r4,r0
;;;230    			break;
0000b4  e00d              B        |L2.210|
;;;231    		case CMD_CODE_APP_READ_RECORDS_PERDATE:
;;;232    			responseLength = HostComm_Cmd_Respond_APP_ReadRecords_PerDate();
0000b6  f7fffffe          BL       HostComm_Cmd_Respond_APP_ReadRecords_PerDate
0000ba  4604              MOV      r4,r0
;;;233    			break;
0000bc  e009              B        |L2.210|
;;;234    #endif
;;;235    #if BLE_4_0_ENABLED
;;;236    		case CMD_CODE_APP_SET_BLE_NAME:
;;;237    			responseLength = HostComm_Cmd_Respond_APP_SetBLEName();
;;;238    			break;
;;;239    #endif
;;;240    #if YINBO_CUSTOMIZATION_ENABLED
;;;241    		case CMD_CODE_APP_SET_INSTITUTE:
;;;242    			responseLength = HostComm_Cmd_Respond_APP_SetInstitute();
;;;243    			break;
;;;244    		case CMD_CODE_APP_CLEAR_IDCARD:
;;;245    			responseLength = HostComm_Cmd_Respond_APP_ClearIDCard();
;;;246    			break;
;;;247    #endif
;;;248    		case CMD_CODE_APP_SET_OUTPUT_DATA:
;;;249    			responseLength = HostComm_Cmd_Respond_APP_SetOutputData();
0000be  f7fffffe          BL       HostComm_Cmd_Respond_APP_SetOutputData
0000c2  4604              MOV      r4,r0
;;;250    			break;
0000c4  e005              B        |L2.210|
                  |L2.198|
;;;251    		default:
;;;252    			responseLength = HostComm_Cmd_Respond_APP_Error(cmdCode);
0000c6  4811              LDR      r0,|L2.268|
0000c8  7800              LDRB     r0,[r0,#0]  ; cmdCode
0000ca  f7fffffe          BL       HostComm_Cmd_Respond_APP_Error
0000ce  4604              MOV      r4,r0
;;;253    			break;
0000d0  bf00              NOP      
                  |L2.210|
0000d2  e00b              B        |L2.236|
                  |L2.212|
;;;254    		}
;;;255    	}
;;;256    	else if (cmdType == CMD_TYPE_NONE)
0000d4  480c              LDR      r0,|L2.264|
0000d6  7800              LDRB     r0,[r0,#0]  ; cmdType
0000d8  b918              CBNZ     r0,|L2.226|
;;;257    	{
;;;258    		/* Get status information */
;;;259    		responseLength = HostComm_Cmd_Respond_Status();
0000da  f7fffffe          BL       HostComm_Cmd_Respond_Status
0000de  4604              MOV      r4,r0
0000e0  e004              B        |L2.236|
                  |L2.226|
;;;260    	}
;;;261    	else
;;;262    	{
;;;263    		/* None BL command: respond error */
;;;264    		responseLength = HostComm_Cmd_Respond_APP_Error(cmdCode);
0000e2  480a              LDR      r0,|L2.268|
0000e4  7800              LDRB     r0,[r0,#0]  ; cmdCode
0000e6  f7fffffe          BL       HostComm_Cmd_Respond_APP_Error
0000ea  4604              MOV      r4,r0
                  |L2.236|
;;;265    	}
;;;266    
;;;267    	/* Send data */
;;;268    	HostComm_SendThrUSB(responseLength, &respBuffer[0]);
0000ec  4908              LDR      r1,|L2.272|
0000ee  4620              MOV      r0,r4
0000f0  f7fffffe          BL       HostComm_SendThrUSB
;;;269    
;;;270    	/* Special case: Launch BL. Launch BL after data is sent. */
;;;271    	if (cmdCode == CMD_CODE_APP_LAUNCH_BL)
0000f4  4805              LDR      r0,|L2.268|
0000f6  7800              LDRB     r0,[r0,#0]  ; cmdCode
0000f8  2811              CMP      r0,#0x11
0000fa  d101              BNE      |L2.256|
;;;272    	{
;;;273    		/* Set to BL mode */
;;;274    //		BL_RUN_TYPE = BL_RUN_TYPE_BL;
;;;275    		/* Software reset */
;;;276    		SoftReset();
0000fc  f7fffffe          BL       SoftReset
                  |L2.256|
;;;277    	}
;;;278    	return rc;
000100  4628              MOV      r0,r5
;;;279    }
000102  bd70              POP      {r4-r6,pc}
;;;280    
                          ENDP

                  |L2.260|
                          DCD      cmdBuffer
                  |L2.264|
                          DCD      cmdType
                  |L2.268|
                          DCD      cmdCode
                  |L2.272|
                          DCD      respBuffer

                          AREA ||i.HostComm_Cmd_Respond_APP_Error||, CODE, READONLY, ALIGN=1

                  HostComm_Cmd_Respond_APP_Error PROC
;;;872    /******************************************************************************/
;;;873    uint16 HostComm_Cmd_Respond_APP_Error(uint8 cmdCode)
000000  b570              PUSH     {r4-r6,lr}
;;;874    {
000002  4604              MOV      r4,r0
;;;875    	uint16 totalPackageLength = SIZE_HEAD_TAIL; /* Include head and tail */
000004  2502              MOVS     r5,#2
;;;876    	uint16 cmdDataLength = 0;
000006  2600              MOVS     r6,#0
;;;877    
;;;878    	totalPackageLength += HostComm_Cmd_Respond_Common(cmdDataLength,
000008  f0440280          ORR      r2,r4,#0x80
00000c  21fe              MOVS     r1,#0xfe
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       HostComm_Cmd_Respond_Common
000014  4428              ADD      r0,r0,r5
000016  b285              UXTH     r5,r0
;;;879    			CMD_TYPE_APP, cmdCode | CMD_ERROR_MASK);
;;;880    
;;;881    	return totalPackageLength;
000018  4628              MOV      r0,r5
;;;882    }
00001a  bd70              POP      {r4-r6,pc}
;;;883    
                          ENDP


                          AREA ||i.HostComm_Cmd_Respond_APP_LaunchBL||, CODE, READONLY, ALIGN=1

                  HostComm_Cmd_Respond_APP_LaunchBL PROC
;;;578    /******************************************************************************/
;;;579    static uint16 HostComm_Cmd_Respond_APP_LaunchBL(void)
000000  b570              PUSH     {r4-r6,lr}
;;;580    {
;;;581    	uint16 totalPackageLength = SIZE_HEAD_TAIL; /* Include head and tail */
000002  2402              MOVS     r4,#2
;;;582    	uint16 cmdDataLength = 0;
000004  2500              MOVS     r5,#0
;;;583    
;;;584    	totalPackageLength += HostComm_Cmd_Respond_Common(cmdDataLength,
000006  2211              MOVS     r2,#0x11
000008  21fe              MOVS     r1,#0xfe
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       HostComm_Cmd_Respond_Common
000010  4420              ADD      r0,r0,r4
000012  b284              UXTH     r4,r0
;;;585    			CMD_TYPE_APP, CMD_CODE_APP_LAUNCH_BL);
;;;586    
;;;587    	return totalPackageLength;
000014  4620              MOV      r0,r4
;;;588    }
000016  bd70              POP      {r4-r6,pc}
;;;589    
                          ENDP


                          AREA ||i.HostComm_Cmd_Respond_APP_ReadIDCard||, CODE, READONLY, ALIGN=1

                  HostComm_Cmd_Respond_APP_ReadIDCard PROC
;;;590    /******************************************************************************/
;;;591    static uint16 HostComm_Cmd_Respond_APP_ReadIDCard(void)
000000  2002              MOVS     r0,#2
;;;592    {
;;;593    	uint16 totalPackageLength = SIZE_HEAD_TAIL; /* Include head and tail */
;;;594    //	uint16 cmdDataLength = 0;
;;;595    //	uint8 dataLengthIDCard = 0;
;;;596    //
;;;597    //	/* Read 256 bytes from ID card */
;;;598    //	if (IDCard_HostRead())
;;;599    //	{
;;;600    //		/* Indicate ID card read success */
;;;601    //		respBuffer[OFFSET_CMD_DATA] = 1;
;;;602    //
;;;603    //		/* Get real data length */
;;;604    ////		dataLengthIDCard = IDCARD_HEAD_LENGTH +
;;;605    ////				8 * IDCard_rxBuffer[IDCARD_POINTS_OFFSET];
;;;606    //		dataLengthIDCard = 0xFF;
;;;607    //
;;;608    //		/* Only move valid data to buffer */
;;;609    //		memcpy(&respBuffer[OFFSET_CMD_DATA + 1], IDCard_rxBuffer,
;;;610    //				dataLengthIDCard);
;;;611    //
;;;612    //		/* Data format: status + data in ID card */
;;;613    //		cmdDataLength = 1 + dataLengthIDCard;
;;;614    //	}
;;;615    //	else
;;;616    //	{
;;;617    //		/* Indicate ID card doesn't exist */
;;;618    //		respBuffer[OFFSET_CMD_DATA] = 0;
;;;619    //		cmdDataLength = 1;
;;;620    //	}
;;;621    //
;;;622    //	totalPackageLength += HostComm_Cmd_Respond_Common(cmdDataLength,
;;;623    //			CMD_TYPE_APP, CMD_CODE_APP_READ_IDCARD);
;;;624    
;;;625    	return totalPackageLength;
;;;626    }
000002  4770              BX       lr
;;;627    
                          ENDP


                          AREA ||i.HostComm_Cmd_Respond_APP_ReadRecords_PerDate||, CODE, READONLY, ALIGN=1

                  HostComm_Cmd_Respond_APP_ReadRecords_PerDate PROC
;;;482    /******************************************************************************/
;;;483    static uint16 HostComm_Cmd_Respond_APP_ReadRecords_PerDate(void)
000000  2002              MOVS     r0,#2
;;;484    {
;;;485    	uint16 totalPackageLength = SIZE_HEAD_TAIL; /* Include head and tail */
;;;486    //	uint16 cmdDataLength = 0;
;;;487    //
;;;488    //	memcpy(&SystemManage_RecordTime, &cmdBuffer[OFFSET_CMD_DATA_RX], 4);
;;;489    //
;;;490    //	if (UI_DATA_TRANSFER_ON == UI_dataTransfer)
;;;491    //	{
;;;492    //		/* Under data transfer mode */
;;;493    //		/* Look up date firstly */
;;;494    //		if (Storage_HaveRecordOrNot(&SystemManage_RecordTime))
;;;495    //		{
;;;496    //			/* Have data */
;;;497    //			respBuffer[OFFSET_CMD_DATA] = 1;
;;;498    //			cmdDataLength = 1;
;;;499    //			UI_readRecord_NewDate = 1;
;;;500    //		}
;;;501    //		else
;;;502    //		{
;;;503    //			/* No data */
;;;504    //			respBuffer[OFFSET_CMD_DATA] = 2;
;;;505    //			cmdDataLength = 1;
;;;506    //			/* Automatically exit data transfer mode */
;;;507    //			UI_dataTransfer = UI_DATA_TRANSFER_OFF;
;;;508    //		}
;;;509    //	}
;;;510    //	else
;;;511    //	{
;;;512    //		/* Not under data transfer mode */
;;;513    //		respBuffer[OFFSET_CMD_DATA] = 0;
;;;514    //		cmdDataLength = 1;
;;;515    //		/* Automatically exit data transfer mode */
;;;516    //		UI_dataTransfer = UI_DATA_TRANSFER_OFF;
;;;517    //	}
;;;518    //
;;;519    //	totalPackageLength += HostComm_Cmd_Respond_Common(cmdDataLength,
;;;520    //			CMD_TYPE_APP, CMD_CODE_APP_READ_RECORDS_PERDATE);
;;;521    
;;;522    	return totalPackageLength;
;;;523    }
000002  4770              BX       lr
;;;524    
                          ENDP


                          AREA ||i.HostComm_Cmd_Respond_APP_ReadResistor||, CODE, READONLY, ALIGN=1

                  HostComm_Cmd_Respond_APP_ReadResistor PROC
;;;740    /******************************************************************************/
;;;741    static uint16 HostComm_Cmd_Respond_APP_ReadResistor(void)
000000  2002              MOVS     r0,#2
;;;742    {
;;;743    	uint16 totalPackageLength = SIZE_HEAD_TAIL; /* Include head and tail */
;;;744    //	uint16 cmdDataLength = 0;
;;;745    //	uint16 value = 0;
;;;746    //
;;;747    //	/* Read from flash */
;;;748    //	STMFlash_Read(FLASH_CALI_RESULT_ADDR, &value, 1);
;;;749    //	SignalSample_resistorValue = value;
;;;750    //	SignalSample_resistorValueStored = value;
;;;751    //
;;;752    //	respBuffer[OFFSET_CMD_DATA] = (uint8)value;
;;;753    //	cmdDataLength = 1;
;;;754    //
;;;755    //	/*  */
;;;756    //	totalPackageLength += HostComm_Cmd_Respond_Common(cmdDataLength,
;;;757    //			CMD_TYPE_APP, CMD_CODE_APP_READ_RESISTOR);
;;;758    
;;;759    	return totalPackageLength;
;;;760    }
000002  4770              BX       lr
;;;761    
                          ENDP


                          AREA ||i.HostComm_Cmd_Respond_APP_SetBLEName||, CODE, READONLY, ALIGN=1

                  HostComm_Cmd_Respond_APP_SetBLEName PROC
;;;723    /******************************************************************************/
;;;724    static uint16 HostComm_Cmd_Respond_APP_SetBLEName(void)
000000  b570              PUSH     {r4-r6,lr}
;;;725    {
;;;726    	uint16 totalPackageLength = SIZE_HEAD_TAIL; /* Include head and tail */
000002  2402              MOVS     r4,#2
;;;727    	uint16 cmdDataLength = 0;
000004  2500              MOVS     r5,#0
;;;728    	uint8 dataLengthIDCard = 0;
000006  2600              MOVS     r6,#0
;;;729    
;;;730    //	BLE_Send_Phone("AT+NAME=RL-A2000");
;;;731    	Delay_ms_SW(100);
000008  2064              MOVS     r0,#0x64
00000a  f7fffffe          BL       Delay_ms_SW
;;;732    //	BLE_Send_Phone("AT+NAME=RL-A2000");
;;;733    
;;;734    	totalPackageLength += HostComm_Cmd_Respond_Common(cmdDataLength,
00000e  221e              MOVS     r2,#0x1e
000010  21fe              MOVS     r1,#0xfe
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       HostComm_Cmd_Respond_Common
000018  4420              ADD      r0,r0,r4
00001a  b284              UXTH     r4,r0
;;;735    			CMD_TYPE_APP, CMD_CODE_APP_SET_BLE_NAME);
;;;736    
;;;737    	return totalPackageLength;
00001c  4620              MOV      r0,r4
;;;738    }
00001e  bd70              POP      {r4-r6,pc}
;;;739    
                          ENDP


                          AREA ||i.HostComm_Cmd_Respond_APP_SetCalcParameters||, CODE, READONLY, ALIGN=1

                  HostComm_Cmd_Respond_APP_SetCalcParameters PROC
;;;788    /******************************************************************************/
;;;789    static uint16 HostComm_Cmd_Respond_APP_SetCalcParameters(void)
000000  2002              MOVS     r0,#2
;;;790    {
;;;791    	uint16 totalPackageLength = SIZE_HEAD_TAIL; /* Include head and tail */
;;;792    //	uint16 cmdDataLength = 0;
;;;793    //	uint16 posInfo[7];
;;;794    //	uint16 posInfoStatus = 1;
;;;795    //
;;;796    //	memcpy(&SignalProcess_Alg_data.posInfo, &cmdBuffer[OFFSET_CMD_DATA_RX], sizeof(STRUCT_POS_INFO));
;;;797    //	memcpy(&posInfo[0], &SignalProcess_Alg_data.posInfo, 13);
;;;798    //
;;;799    //	STMFlash_Write(FLASH_CALC_POSINFO_STATUS_ADDR, &posInfoStatus, 1);
;;;800    //	STMFlash_Write(FLASH_CALC_POSINFO_DATA_ADDR, &posInfo[0], 7);
;;;801    //
;;;802    //	totalPackageLength += HostComm_Cmd_Respond_Common(cmdDataLength,
;;;803    //			CMD_TYPE_APP, CMD_CODE_APP_SET_CALC_PARAMETERS);
;;;804    
;;;805    	return totalPackageLength;
;;;806    }
000002  4770              BX       lr
;;;807    
                          ENDP


                          AREA ||i.HostComm_Cmd_Respond_APP_SetLanguage||, CODE, READONLY, ALIGN=1

                  HostComm_Cmd_Respond_APP_SetLanguage PROC
;;;394    /******************************************************************************/
;;;395    static uint16 HostComm_Cmd_Respond_APP_SetLanguage(void)
000000  2002              MOVS     r0,#2
;;;396    {
;;;397    	uint16 totalPackageLength = SIZE_HEAD_TAIL; /* Include head and tail */
;;;398    //	uint16 cmdDataLength = 0;
;;;399    //
;;;400    //	/*  */
;;;401    //	memcpy(&UI_Language, &cmdBuffer[OFFSET_CMD_DATA_RX], 2);
;;;402    //
;;;403    //	STMFlash_Write(FLASH_SET_LANGUAGE_ADDR, &UI_Language, 1);
;;;404    //
;;;405    //	totalPackageLength += HostComm_Cmd_Respond_Common(cmdDataLength,
;;;406    //			CMD_TYPE_APP, CMD_CODE_APP_SET_LANGUAGE);
;;;407    
;;;408    	return totalPackageLength;
;;;409    }
000002  4770              BX       lr
;;;410    
                          ENDP


                          AREA ||i.HostComm_Cmd_Respond_APP_SetMFG||, CODE, READONLY, ALIGN=1

                  HostComm_Cmd_Respond_APP_SetMFG PROC
;;;372    /******************************************************************************/
;;;373    static uint16 HostComm_Cmd_Respond_APP_SetMFG(void)
000000  2002              MOVS     r0,#2
;;;374    {
;;;375    	uint16 totalPackageLength = SIZE_HEAD_TAIL; /* Include head and tail */
;;;376    //	uint16 cmdDataLength = 0;
;;;377    //
;;;378    //	/* SN: 20161031001 */
;;;379    //	memcpy(UI_MFG, &cmdBuffer[OFFSET_CMD_DATA_RX], 8);
;;;380    //
;;;381    //	STMFlash_Write(FLASH_SET_MFG_ADDR, UI_MFG, 4);
;;;382    //
;;;383    //	UI_MFG_SN = (UI_MFG[1] << 16) + UI_MFG[0];
;;;384    //	UI_MFG_FW1 = 0x00FF & UI_MFG[2];
;;;385    //	UI_MFG_FW2 = (0xFF00 & UI_MFG[2]) >> 8;
;;;386    //	UI_MFG_FW3 = UI_MFG[3];
;;;387    //
;;;388    //	totalPackageLength += HostComm_Cmd_Respond_Common(cmdDataLength,
;;;389    //			CMD_TYPE_APP, CMD_CODE_APP_SET_MFG);
;;;390    
;;;391    	return totalPackageLength;
;;;392    }
000002  4770              BX       lr
;;;393    
                          ENDP


                          AREA ||i.HostComm_Cmd_Respond_APP_SetMode||, CODE, READONLY, ALIGN=1

                  HostComm_Cmd_Respond_APP_SetMode PROC
;;;348    /******************************************************************************/
;;;349    static uint16 HostComm_Cmd_Respond_APP_SetMode(void)
000000  2002              MOVS     r0,#2
;;;350    {
;;;351    	uint16 totalPackageLength = SIZE_HEAD_TAIL; /* Include head and tail */
;;;352    //	uint16 cmdDataLength = 0;
;;;353    //
;;;354    //	/*  */
;;;355    //	if (cmdBuffer[OFFSET_CMD_DATA_RX] == 1)
;;;356    //	{
;;;357    //		UI_runMode = UI_MODE_DEBUG;
;;;358    //	}
;;;359    //	else
;;;360    //	{
;;;361    //		UI_runMode = UI_MODE_NORMAL;
;;;362    //	}
;;;363    //	STMFlash_Write(FLASH_SET_MODE_ADDR, &UI_runMode, 1);
;;;364    //
;;;365    //	/*  */
;;;366    //	totalPackageLength += HostComm_Cmd_Respond_Common(cmdDataLength,
;;;367    //			CMD_TYPE_APP, CMD_CODE_APP_SET_MODE);
;;;368    
;;;369    	return totalPackageLength;
;;;370    }
000002  4770              BX       lr
;;;371    
                          ENDP


                          AREA ||i.HostComm_Cmd_Respond_APP_SetOutFab||, CODE, READONLY, ALIGN=1

                  HostComm_Cmd_Respond_APP_SetOutFab PROC
;;;428    /******************************************************************************/
;;;429    static uint16 HostComm_Cmd_Respond_APP_SetOutFab(void)
000000  2002              MOVS     r0,#2
;;;430    {
;;;431    	uint16 totalPackageLength = SIZE_HEAD_TAIL; /* Include head and tail */
;;;432    //	uint16 cmdDataLength = 0;
;;;433    //
;;;434    //	uint16 value = 0;
;;;435    //
;;;436    //	/* Set out fab calibration value, then user can recover it */
;;;437    //	value = SignalSample_resistorValueStored;
;;;438    //	STMFlash_Write(FLASH_SET_OUT_FAB, &value, 1);
;;;439    //
;;;440    //	totalPackageLength += HostComm_Cmd_Respond_Common(cmdDataLength,
;;;441    //			CMD_TYPE_APP, CMD_CODE_APP_SET_OUT_FAB);
;;;442    
;;;443    	return totalPackageLength;
;;;444    }
000002  4770              BX       lr
;;;445    
                          ENDP


                          AREA ||i.HostComm_Cmd_Respond_APP_SetOutputData||, CODE, READONLY, ALIGN=2

                  HostComm_Cmd_Respond_APP_SetOutputData PROC
;;;853    /******************************************************************************/
;;;854    static uint16 HostComm_Cmd_Respond_APP_SetOutputData(void)
000000  b570              PUSH     {r4-r6,lr}
;;;855    {
;;;856    	uint16 totalPackageLength = SIZE_HEAD_TAIL; /* Include head and tail */
000002  2402              MOVS     r4,#2
;;;857    	uint16 cmdDataLength = 0;
000004  2500              MOVS     r5,#0
;;;858    	uint8 dataLengthIDCard = 0;
000006  2600              MOVS     r6,#0
;;;859    
;;;860    	SignalProcess_output = 1;
000008  2001              MOVS     r0,#1
00000a  4907              LDR      r1,|L14.40|
00000c  7008              STRB     r0,[r1,#0]
;;;861    
;;;862    	/* Respond to host */
;;;863    	respBuffer[OFFSET_CMD_DATA] = 1;
00000e  4907              LDR      r1,|L14.44|
000010  7148              STRB     r0,[r1,#5]
;;;864    	cmdDataLength = 1;
000012  2501              MOVS     r5,#1
;;;865    
;;;866    	totalPackageLength += HostComm_Cmd_Respond_Common(cmdDataLength,
000014  2221              MOVS     r2,#0x21
000016  21fe              MOVS     r1,#0xfe
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       HostComm_Cmd_Respond_Common
00001e  4420              ADD      r0,r0,r4
000020  b284              UXTH     r4,r0
;;;867    			CMD_TYPE_APP, CMD_CODE_APP_SET_OUTPUT_DATA);
;;;868    
;;;869    	return totalPackageLength;
000022  4620              MOV      r0,r4
;;;870    }
000024  bd70              POP      {r4-r6,pc}
;;;871    
                          ENDP

000026  0000              DCW      0x0000
                  |L14.40|
                          DCD      SignalProcess_output
                  |L14.44|
                          DCD      respBuffer

                          AREA ||i.HostComm_Cmd_Respond_APP_SetPrinter||, CODE, READONLY, ALIGN=1

                  HostComm_Cmd_Respond_APP_SetPrinter PROC
;;;411    /******************************************************************************/
;;;412    static uint16 HostComm_Cmd_Respond_APP_SetPrinter(void)
000000  2002              MOVS     r0,#2
;;;413    {
;;;414    	uint16 totalPackageLength = SIZE_HEAD_TAIL; /* Include head and tail */
;;;415    //	uint16 cmdDataLength = 0;
;;;416    //
;;;417    //	/*  */
;;;418    //	memcpy(&UI_Printer, &cmdBuffer[OFFSET_CMD_DATA_RX], 2);
;;;419    //
;;;420    //	STMFlash_Write(FLASH_SET_PRINTER_ADDR, &UI_Printer, 1);
;;;421    //
;;;422    //	totalPackageLength += HostComm_Cmd_Respond_Common(cmdDataLength,
;;;423    //			CMD_TYPE_APP, CMD_CODE_APP_SET_PRINTER);
;;;424    
;;;425    	return totalPackageLength;
;;;426    }
000002  4770              BX       lr
;;;427    
                          ENDP


                          AREA ||i.HostComm_Cmd_Respond_APP_SetTime||, CODE, READONLY, ALIGN=2

                  HostComm_Cmd_Respond_APP_SetTime PROC
;;;675    /******************************************************************************/
;;;676    static uint16 HostComm_Cmd_Respond_APP_SetTime(void)
000000  b570              PUSH     {r4-r6,lr}
;;;677    {
000002  b088              SUB      sp,sp,#0x20
;;;678    	uint16 totalPackageLength = SIZE_HEAD_TAIL; /* Include head and tail */
000004  2402              MOVS     r4,#2
;;;679    	uint16 cmdDataLength = 0;
000006  2500              MOVS     r5,#0
;;;680    	uint16 dataBuf[10] = {0};
000008  2114              MOVS     r1,#0x14
00000a  a803              ADD      r0,sp,#0xc
00000c  f7fffffe          BL       __aeabi_memclr4
;;;681    
;;;682    	memcpy(&SystemManage_SetTime, &cmdBuffer[OFFSET_CMD_DATA_RX],
000010  4814              LDR      r0,|L16.100|
000012  4915              LDR      r1,|L16.104|
000014  f8d12002          LDR      r2,[r1,#2]  ; cmdBuffer
000018  6002              STR      r2,[r0,#0]  ; SystemManage_SetTime
00001a  f8d11006          LDR      r1,[r1,#6]  ; cmdBuffer
00001e  6041              STR      r1,[r0,#4]  ; SystemManage_SetTime
;;;683    			sizeof(RTC_DATA));
;;;684    
;;;685    //	memcpy(&SignalSample_caliStdRatioCT,
;;;686    //			&cmdBuffer[OFFSET_CMD_DATA_RX + 7], sizeof(float));
;;;687    
;;;688    	/* Set time */
;;;689    	SystemManage_RTC_Set(SystemManage_SetTime.year,
000020  7980              LDRB     r0,[r0,#6]  ; SystemManage_SetTime
000022  4910              LDR      r1,|L16.100|
000024  7949              LDRB     r1,[r1,#5]  ; SystemManage_SetTime
000026  4e0f              LDR      r6,|L16.100|
000028  e9cd1000          STRD     r1,r0,[sp,#0]
00002c  7933              LDRB     r3,[r6,#4]  ; SystemManage_SetTime
00002e  78f2              LDRB     r2,[r6,#3]  ; SystemManage_SetTime
000030  78b1              LDRB     r1,[r6,#2]  ; SystemManage_SetTime
000032  8830              LDRH     r0,[r6,#0]  ; SystemManage_SetTime
000034  f7fffffe          BL       SystemManage_RTC_Set
;;;690    			SystemManage_SetTime.month, SystemManage_SetTime.day,
;;;691    			SystemManage_SetTime.hour, SystemManage_SetTime.min,
;;;692    			SystemManage_SetTime.sec);
;;;693    
;;;694    	/* Read time */
;;;695    	SystemManage_RTC_Get();
000038  f7fffffe          BL       SystemManage_RTC_Get
;;;696    
;;;697    //	/* Update time */
;;;698    //	UI_Process_Update_StatusBar();
;;;699    
;;;700    //	/* Clear head of record area */
;;;701    //	Storage_Clear();
;;;702    
;;;703    	/* Record set time */
;;;704    	memcpy(dataBuf, &SystemManage_SetTime, sizeof(RTC_DATA));
00003c  4630              MOV      r0,r6
00003e  6801              LDR      r1,[r0,#0]  ; SystemManage_SetTime
000040  9103              STR      r1,[sp,#0xc]
000042  6840              LDR      r0,[r0,#4]  ; SystemManage_SetTime
000044  9004              STR      r0,[sp,#0x10]
;;;705    //	STMFlash_Write(FLASH_SET_TIME_ADDR, dataBuf, sizeof(RTC_DATA) >> 1);
;;;706    //
;;;707    //	/* Store standard ratio of CT */
;;;708    //	memcpy(floatBuf, &SignalSample_caliStdRatioCT,
;;;709    //			sizeof(SignalSample_caliStdRatioCT));
;;;710    //	STMFlash_Write(FLASH_CALI_STD_RATIOCT_ADDR, floatBuf, 2);
;;;711    
;;;712    	/* Respond to host */
;;;713    	respBuffer[OFFSET_CMD_DATA] = 1;
000046  2001              MOVS     r0,#1
000048  4908              LDR      r1,|L16.108|
00004a  7148              STRB     r0,[r1,#5]
;;;714    
;;;715    	cmdDataLength = 1;
00004c  2501              MOVS     r5,#1
;;;716    
;;;717    	totalPackageLength += HostComm_Cmd_Respond_Common(cmdDataLength,
00004e  2214              MOVS     r2,#0x14
000050  21fe              MOVS     r1,#0xfe
000052  4628              MOV      r0,r5
000054  f7fffffe          BL       HostComm_Cmd_Respond_Common
000058  4420              ADD      r0,r0,r4
00005a  b284              UXTH     r4,r0
;;;718    			CMD_TYPE_APP, CMD_CODE_APP_SET_TIME);
;;;719    
;;;720    	return totalPackageLength;
00005c  4620              MOV      r0,r4
;;;721    }
00005e  b008              ADD      sp,sp,#0x20
000060  bd70              POP      {r4-r6,pc}
;;;722    
                          ENDP

000062  0000              DCW      0x0000
                  |L16.100|
                          DCD      SystemManage_SetTime
                  |L16.104|
                          DCD      cmdBuffer
                  |L16.108|
                          DCD      respBuffer

                          AREA ||i.HostComm_Cmd_Respond_APP_StartStop_ReadRecords||, CODE, READONLY, ALIGN=1

                  HostComm_Cmd_Respond_APP_StartStop_ReadRecords PROC
;;;447    /******************************************************************************/
;;;448    static uint16 HostComm_Cmd_Respond_APP_StartStop_ReadRecords(void)
000000  2002              MOVS     r0,#2
;;;449    {
;;;450    	uint16 totalPackageLength = SIZE_HEAD_TAIL; /* Include head and tail */
;;;451    //	uint16 cmdDataLength = 0;
;;;452    //
;;;453    //	if (1 == cmdBuffer[OFFSET_CMD_DATA_RX])
;;;454    //	{
;;;455    //		/* Start */
;;;456    //		/* Only read records under MAIN interface */
;;;457    //		if (UI_state == UI_STATE_MAIN_WINDOW)
;;;458    //		{
;;;459    //			UI_dataTransfer = UI_DATA_TRANSFER_ON;
;;;460    //			respBuffer[OFFSET_CMD_DATA] = 1;
;;;461    //		}
;;;462    //		else
;;;463    //		{
;;;464    //			respBuffer[OFFSET_CMD_DATA] = 0;
;;;465    //		}
;;;466    //	}
;;;467    //	else if (0 == cmdBuffer[OFFSET_CMD_DATA_RX])
;;;468    //	{
;;;469    //		/* Stop */
;;;470    //		UI_dataTransfer = UI_DATA_TRANSFER_OFF;
;;;471    //		respBuffer[OFFSET_CMD_DATA] = 2;
;;;472    //	}
;;;473    //
;;;474    //	cmdDataLength = 1;
;;;475    //
;;;476    //	totalPackageLength += HostComm_Cmd_Respond_Common(cmdDataLength,
;;;477    //			CMD_TYPE_APP, CMD_CODE_APP_START_STOP_READ_RECORD);
;;;478    
;;;479    	return totalPackageLength;
;;;480    }
000002  4770              BX       lr
;;;481    
                          ENDP


                          AREA ||i.HostComm_Cmd_Respond_APP_SysInfo||, CODE, READONLY, ALIGN=2

                  HostComm_Cmd_Respond_APP_SysInfo PROC
;;;554    /******************************************************************************/
;;;555    static uint16 HostComm_Cmd_Respond_APP_SysInfo(void)
000000  b570              PUSH     {r4-r6,lr}
;;;556    {
;;;557    	uint16 totalPackageLength = SIZE_HEAD_TAIL; /* Include head and tail */
000002  2402              MOVS     r4,#2
;;;558    	uint16 cmdDataLength = 0;
000004  2500              MOVS     r5,#0
;;;559    
;;;560    	/* Product ID */
;;;561    	respBuffer[OFFSET_CMD_DATA] = 1;
000006  2001              MOVS     r0,#1
000008  490d              LDR      r1,|L18.64|
00000a  7148              STRB     r0,[r1,#5]
;;;562    	respBuffer[OFFSET_CMD_DATA + 1] = 0;
00000c  2000              MOVS     r0,#0
00000e  7188              STRB     r0,[r1,#6]
;;;563    
;;;564    	/* Version information */
;;;565    	respBuffer[OFFSET_CMD_DATA + 2] = LoByte(APP_REVISION);
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       LoByte
000016  490a              LDR      r1,|L18.64|
000018  71c8              STRB     r0,[r1,#7]
;;;566    	respBuffer[OFFSET_CMD_DATA + 3] = HiByte(APP_REVISION);
00001a  2001              MOVS     r0,#1
00001c  f7fffffe          BL       HiByte
000020  4907              LDR      r1,|L18.64|
000022  7208              STRB     r0,[r1,#8]
;;;567    	respBuffer[OFFSET_CMD_DATA + 4] = APP_VERSION_MINOR;
000024  2000              MOVS     r0,#0
000026  7248              STRB     r0,[r1,#9]
;;;568    	respBuffer[OFFSET_CMD_DATA + 5] = APP_VERSION_MAJOR;
000028  2001              MOVS     r0,#1
00002a  7288              STRB     r0,[r1,#0xa]
;;;569    
;;;570    	cmdDataLength = 6;
00002c  2506              MOVS     r5,#6
;;;571    
;;;572    	totalPackageLength += HostComm_Cmd_Respond_Common(cmdDataLength,
00002e  2210              MOVS     r2,#0x10
000030  21fe              MOVS     r1,#0xfe
000032  4628              MOV      r0,r5
000034  f7fffffe          BL       HostComm_Cmd_Respond_Common
000038  4420              ADD      r0,r0,r4
00003a  b284              UXTH     r4,r0
;;;573    			CMD_TYPE_APP, CMD_CODE_APP_SYSINFO);
;;;574    
;;;575    	return totalPackageLength;
00003c  4620              MOV      r0,r4
;;;576    }
00003e  bd70              POP      {r4-r6,pc}
;;;577    
                          ENDP

                  |L18.64|
                          DCD      respBuffer

                          AREA ||i.HostComm_Cmd_Respond_APP_WriteIDCard||, CODE, READONLY, ALIGN=1

                  HostComm_Cmd_Respond_APP_WriteIDCard PROC
;;;628    /******************************************************************************/
;;;629    static uint16 HostComm_Cmd_Respond_APP_WriteIDCard(void)
000000  2002              MOVS     r0,#2
;;;630    {
;;;631    	uint16 totalPackageLength = SIZE_HEAD_TAIL; /* Include head and tail */
;;;632    //	uint16 cmdDataLength = 0;
;;;633    //	uint8 dataLengthIDCard = 0;
;;;634    //
;;;635    //	/* Write to ID card */
;;;636    //	if (IDCard_IsCardInserted())
;;;637    //	{
;;;638    //		/* Clear buffer */
;;;639    //		memset(IDCard_txBuffer, 0x00, 0xFF);
;;;640    //
;;;641    //		/* Clear E2 before write data */
;;;642    //		if (!IDCard_HostWrite())
;;;643    //		{
;;;644    //			/* Get valid data length */
;;;645    ////			dataLengthIDCard = IDCARD_HEAD_LENGTH +
;;;646    ////					8 * cmdBuffer[OFFSET_CMD_DATA_RX + IDCARD_POINTS_OFFSET];
;;;647    //			dataLengthIDCard = 0xFF;
;;;648    //
;;;649    //			/* Move valid data */
;;;650    //			memcpy(IDCard_txBuffer, &cmdBuffer[OFFSET_CMD_DATA_RX], dataLengthIDCard);
;;;651    //
;;;652    //			/* Execute write operation */
;;;653    //			IDCard_HostWrite();
;;;654    //
;;;655    //			respBuffer[OFFSET_CMD_DATA] = 1;
;;;656    //		}
;;;657    //		else
;;;658    //		{
;;;659    //			respBuffer[OFFSET_CMD_DATA] = 0;
;;;660    //		}
;;;661    //	}
;;;662    //	else
;;;663    //	{
;;;664    //		respBuffer[OFFSET_CMD_DATA] = 0;
;;;665    //	}
;;;666    //
;;;667    //	cmdDataLength = 1;
;;;668    //
;;;669    //	totalPackageLength += HostComm_Cmd_Respond_Common(cmdDataLength,
;;;670    //			CMD_TYPE_APP, CMD_CODE_APP_WRITE_IDCARD);
;;;671    
;;;672    	return totalPackageLength;
;;;673    }
000002  4770              BX       lr
;;;674    
                          ENDP


                          AREA ||i.HostComm_Cmd_Respond_APP_WriteResistor||, CODE, READONLY, ALIGN=1

                  HostComm_Cmd_Respond_APP_WriteResistor PROC
;;;762    /******************************************************************************/
;;;763    static uint16 HostComm_Cmd_Respond_APP_WriteResistor(void)
000000  2002              MOVS     r0,#2
;;;764    {
;;;765    	uint16 totalPackageLength = SIZE_HEAD_TAIL; /* Include head and tail */
;;;766    //	uint16 cmdDataLength = 0;
;;;767    //	uint16 value = 0;
;;;768    //
;;;769    //	/*  */
;;;770    //	if (cmdBuffer[OFFSET_CMD_DATA_RX] <= 0xFF)
;;;771    //	{
;;;772    //		value = CALI_VALID;
;;;773    //		STMFlash_Write(FLASH_CALI_STATUS_ADDR, &value, 1);
;;;774    //		value = cmdBuffer[OFFSET_CMD_DATA_RX];
;;;775    //		STMFlash_Write(FLASH_CALI_RESULT_ADDR, &value, 1);
;;;776    //		SignalSample_digitalResistor = value;
;;;777    //		SignalSample_resistorValue = value;
;;;778    //		SignalSample_resistorValueStored = value;
;;;779    //	}
;;;780    //
;;;781    //	/*  */
;;;782    //	totalPackageLength += HostComm_Cmd_Respond_Common(cmdDataLength,
;;;783    //			CMD_TYPE_APP, CMD_CODE_APP_WRITE_RESISTOR);
;;;784    
;;;785    	return totalPackageLength;
;;;786    }
000002  4770              BX       lr
;;;787    
                          ENDP


                          AREA ||i.HostComm_Cmd_Respond_Common||, CODE, READONLY, ALIGN=2

                  HostComm_Cmd_Respond_Common PROC
;;;293    /******************************************************************************/
;;;294    static uint16 HostComm_Cmd_Respond_Common(uint16 cmdDataNum, uint8 cmdType,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;295    		uint8 cmdCode)
;;;296    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;297    	uint16 packageLength = SIZE_LEN_HEAD_CMD_CRC + cmdDataNum;
00000a  1da0              ADDS     r0,r4,#6
00000c  b287              UXTH     r7,r0
;;;298    	uint16 crcCal = 0;
00000e  f04f0800          MOV      r8,#0
;;;299    
;;;300    	/* Head */
;;;301    	respBuffer[OFFSET_HEADER] = '$';
000012  2024              MOVS     r0,#0x24
000014  4914              LDR      r1,|L21.104|
000016  7008              STRB     r0,[r1,#0]
;;;302    
;;;303    	/* Package length */
;;;304    	respBuffer[OFFSET_LEN_LO] = LoByte(packageLength);
000018  4638              MOV      r0,r7
00001a  f7fffffe          BL       LoByte
00001e  4912              LDR      r1,|L21.104|
000020  7048              STRB     r0,[r1,#1]
;;;305    	respBuffer[OFFSET_LEN_HI] = HiByte(packageLength);
000022  4638              MOV      r0,r7
000024  f7fffffe          BL       HiByte
000028  490f              LDR      r1,|L21.104|
00002a  7088              STRB     r0,[r1,#2]
;;;306    
;;;307    	/* Command type and code */
;;;308    	respBuffer[OFFSET_CMD_TYPE] = cmdType;
00002c  4608              MOV      r0,r1
00002e  70c5              STRB     r5,[r0,#3]
;;;309    	respBuffer[OFFSET_CMD_CODE] = cmdCode;
000030  7106              STRB     r6,[r0,#4]
;;;310    
;;;311    	/* Calculate CRC
;;;312    	 * 1. &cmdBuffer[1]: because the first byte is '$' which is not included
;;;313    	 *    in CRC calculation
;;;314    	 * 2. cmdLength - 2: because cmdLength includes 2-byte CRC */
;;;315    	crcCal = Common_CalculateCRC(&respBuffer[1], packageLength - 2, 0xFFFF,
000032  1eb9              SUBS     r1,r7,#2
000034  2300              MOVS     r3,#0
000036  f64f72ff          MOV      r2,#0xffff
00003a  1c40              ADDS     r0,r0,#1
00003c  f7fffffe          BL       Common_CalculateCRC
000040  4680              MOV      r8,r0
;;;316    									0x0000);
;;;317    
;;;318    	/* CRC */
;;;319    	respBuffer[OFFSET_CMD_DATA + cmdDataNum] = LoByte(crcCal);
000042  4640              MOV      r0,r8
000044  f7fffffe          BL       LoByte
000048  1d61              ADDS     r1,r4,#5
00004a  4a07              LDR      r2,|L21.104|
00004c  5450              STRB     r0,[r2,r1]
;;;320    	respBuffer[OFFSET_CMD_DATA + cmdDataNum + 1] = HiByte(crcCal);
00004e  4640              MOV      r0,r8
000050  f7fffffe          BL       HiByte
000054  4601              MOV      r1,r0
000056  1da0              ADDS     r0,r4,#6
000058  4a03              LDR      r2,|L21.104|
00005a  5411              STRB     r1,[r2,r0]
;;;321    
;;;322    	/* Tail */
;;;323    	respBuffer[OFFSET_CMD_DATA + cmdDataNum + 2] = '#';
00005c  2123              MOVS     r1,#0x23
00005e  1de0              ADDS     r0,r4,#7
000060  5411              STRB     r1,[r2,r0]
;;;324    
;;;325    	return packageLength;
000062  4638              MOV      r0,r7
;;;326    }
000064  e8bd81f0          POP      {r4-r8,pc}
;;;327    
                          ENDP

                  |L21.104|
                          DCD      respBuffer

                          AREA ||i.HostComm_Cmd_Respond_Status||, CODE, READONLY, ALIGN=2

                  HostComm_Cmd_Respond_Status PROC
;;;328    /******************************************************************************/
;;;329    static uint16 HostComm_Cmd_Respond_Status(void)
000000  b570              PUSH     {r4-r6,lr}
;;;330    {
;;;331    	uint16 totalPackageLength = SIZE_HEAD_TAIL; /* Include head and tail */
000002  2402              MOVS     r4,#2
;;;332    	uint16 cmdDataLength = 0;
000004  2500              MOVS     r5,#0
;;;333    
;;;334    	/* Status:
;;;335    	 * 0: BL
;;;336    	 * 1: APP
;;;337    	 *  */
;;;338    	respBuffer[OFFSET_CMD_DATA] = 1;
000006  2001              MOVS     r0,#1
000008  4905              LDR      r1,|L22.32|
00000a  7148              STRB     r0,[r1,#5]
;;;339    
;;;340    	cmdDataLength = 1;
00000c  2501              MOVS     r5,#1
;;;341    
;;;342    	totalPackageLength += HostComm_Cmd_Respond_Common(cmdDataLength,
00000e  2200              MOVS     r2,#0
000010  4611              MOV      r1,r2
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       HostComm_Cmd_Respond_Common
000018  4420              ADD      r0,r0,r4
00001a  b284              UXTH     r4,r0
;;;343    			CMD_TYPE_NONE, CMD_CODE_STATUS);
;;;344    
;;;345    	return totalPackageLength;
00001c  4620              MOV      r0,r4
;;;346    }
00001e  bd70              POP      {r4-r6,pc}
;;;347    
                          ENDP

                  |L22.32|
                          DCD      respBuffer

                          AREA ||i.HostComm_Config||, CODE, READONLY, ALIGN=2

                  HostComm_Config PROC
;;;106    /******************************************************************************/
;;;107    static void HostComm_Config()
000000  b51f              PUSH     {r0-r4,lr}
;;;108    {
;;;109    	USART_InitTypeDef USART_InitStructure;
;;;110    
;;;111    	USART_InitStructure.USART_BaudRate = 115200;
000002  f44f30e1          MOV      r0,#0x1c200
000006  9000              STR      r0,[sp,#0]
;;;112    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000008  2000              MOVS     r0,#0
00000a  f8ad0004          STRH     r0,[sp,#4]
;;;113    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
00000e  f8ad0006          STRH     r0,[sp,#6]
;;;114    	USART_InitStructure.USART_Parity = USART_Parity_No;
000012  f8ad0008          STRH     r0,[sp,#8]
;;;115    	USART_InitStructure.USART_HardwareFlowControl =
000016  f8ad000c          STRH     r0,[sp,#0xc]
;;;116    			USART_HardwareFlowControl_None;
;;;117    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00001a  200c              MOVS     r0,#0xc
00001c  f8ad000a          STRH     r0,[sp,#0xa]
;;;118    	/* Configure */
;;;119    	USART_Init(HOSTCOMM_USART, &USART_InitStructure);
000020  4669              MOV      r1,sp
000022  4809              LDR      r0,|L23.72|
000024  f7fffffe          BL       USART_Init
;;;120    	/* Enable Receive and Transmit interrupts */
;;;121    	USART_ITConfig(HOSTCOMM_USART, USART_IT_RXNE, ENABLE);
000028  2201              MOVS     r2,#1
00002a  f2405125          MOV      r1,#0x525
00002e  4806              LDR      r0,|L23.72|
000030  f7fffffe          BL       USART_ITConfig
;;;122    //	USART_ITConfig(HOSTCOMM_USART, USART_IT_TXE, ENABLE);
;;;123    	/* Enable */
;;;124    	USART_Cmd(HOSTCOMM_USART, ENABLE);
000034  2101              MOVS     r1,#1
000036  4804              LDR      r0,|L23.72|
000038  f7fffffe          BL       USART_Cmd
;;;125    	/* To avoid the first byte missing issue */
;;;126    	USART_ClearFlag(HOSTCOMM_USART, USART_FLAG_TC);
00003c  2140              MOVS     r1,#0x40
00003e  4802              LDR      r0,|L23.72|
000040  f7fffffe          BL       USART_ClearFlag
;;;127    }
000044  bd1f              POP      {r0-r4,pc}
;;;128    
                          ENDP

000046  0000              DCW      0x0000
                  |L23.72|
                          DCD      0x40004400

                          AREA ||i.HostComm_Init||, CODE, READONLY, ALIGN=1

                  HostComm_Init PROC
;;;129    /******************************************************************************/
;;;130    void HostComm_Init()
000000  b510              PUSH     {r4,lr}
;;;131    {
;;;132    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
000002  2101              MOVS     r1,#1
000004  0448              LSLS     r0,r1,#17
000006  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;133    	/*Initialize GPIOs*/
;;;134    //	HostComm_GPIO_Init();
;;;135    	/*Enable interrupt*/
;;;136    	HostComm_NVIC_Configuration();
00000a  f7fffffe          BL       HostComm_NVIC_Configuration
;;;137    	/*Configure parameters*/
;;;138    	HostComm_Config();
00000e  f7fffffe          BL       HostComm_Config
;;;139    }
000012  bd10              POP      {r4,pc}
;;;140    
                          ENDP


                          AREA ||i.HostComm_NVIC_Configuration||, CODE, READONLY, ALIGN=1

                  HostComm_NVIC_Configuration PROC
;;;74     /******************************************************************************/
;;;75     static void HostComm_NVIC_Configuration()
000000  b508              PUSH     {r3,lr}
;;;76     {
;;;77     	NVIC_InitTypeDef NVIC_InitStructure;
;;;78     
;;;79     	//  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
;;;80     
;;;81     	/*Enable interrupt*/
;;;82     	NVIC_InitStructure.NVIC_IRQChannel = HOSTCOMM_USART_IRQN;
000002  2026              MOVS     r0,#0x26
000004  f88d0000          STRB     r0,[sp,#0]
;;;83     	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 3;
000008  2003              MOVS     r0,#3
00000a  f88d0001          STRB     r0,[sp,#1]
;;;84     	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;
00000e  f88d0002          STRB     r0,[sp,#2]
;;;85     	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000012  2001              MOVS     r0,#1
000014  f88d0003          STRB     r0,[sp,#3]
;;;86     	NVIC_Init(&NVIC_InitStructure);
000018  4668              MOV      r0,sp
00001a  f7fffffe          BL       NVIC_Init
;;;87     }
00001e  bd08              POP      {r3,pc}
;;;88     
                          ENDP


                          AREA ||i.HostComm_Process||, CODE, READONLY, ALIGN=2

                  HostComm_Process PROC
;;;141    /******************************************************************************/
;;;142    void HostComm_Process(void)
000000  b510              PUSH     {r4,lr}
;;;143    {
;;;144    	if (HostComm_RecBufAvailable)
000002  4804              LDR      r0,|L26.20|
000004  7800              LDRB     r0,[r0,#0]  ; HostComm_RecBufAvailable
000006  b120              CBZ      r0,|L26.18|
;;;145    	{
;;;146    		/* Receive host command */
;;;147    		HostComm_RecBufAvailable = 0;
000008  2000              MOVS     r0,#0
00000a  4902              LDR      r1,|L26.20|
00000c  7008              STRB     r0,[r1,#0]
;;;148    		HostComm_Cmd_Process();
00000e  f7fffffe          BL       HostComm_Cmd_Process
                  |L26.18|
;;;149    	}
;;;150    }
000012  bd10              POP      {r4,pc}
;;;151    
                          ENDP

                  |L26.20|
                          DCD      HostComm_RecBufAvailable

                          AREA ||i.HostComm_Report_ReadRecords||, CODE, READONLY, ALIGN=2

                  HostComm_Report_ReadRecords PROC
;;;525    /******************************************************************************/
;;;526    void HostComm_Report_ReadRecords(HOSTCOMM_REPORT_ATTR data)
000000  b40f              PUSH     {r0-r3}
;;;527    {
000002  b570              PUSH     {r4-r6,lr}
;;;528    	uint16 totalPackageLength = SIZE_HEAD_TAIL; /* Include head and tail */
000004  2402              MOVS     r4,#2
;;;529    	uint16 cmdDataLength = sizeof(HOSTCOMM_REPORT_ATTR);
000006  f44f75d0          MOV      r5,#0x1a0
;;;530    
;;;531    	memcpy(&respBuffer[OFFSET_CMD_DATA], &data, cmdDataLength);
00000a  462a              MOV      r2,r5
00000c  a904              ADD      r1,sp,#0x10
00000e  4809              LDR      r0,|L27.52|
000010  f7fffffe          BL       __aeabi_memcpy
;;;532    
;;;533    	totalPackageLength += HostComm_Cmd_Respond_Common(cmdDataLength,
000014  221c              MOVS     r2,#0x1c
000016  21fe              MOVS     r1,#0xfe
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       HostComm_Cmd_Respond_Common
00001e  4420              ADD      r0,r0,r4
000020  b284              UXTH     r4,r0
;;;534    			CMD_TYPE_APP, CMD_CODE_APP_READ_RECORD);
;;;535    
;;;536    	/* Send data */
;;;537    	HostComm_SendThrUSB(totalPackageLength, &respBuffer[0]);
000022  4904              LDR      r1,|L27.52|
000024  1f49              SUBS     r1,r1,#5
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       HostComm_SendThrUSB
;;;538    }
00002c  bc70              POP      {r4-r6}
00002e  f85dfb14          LDR      pc,[sp],#0x14
;;;539    
                          ENDP

000032  0000              DCW      0x0000
                  |L27.52|
                          DCD      respBuffer+0x5

                          AREA ||i.HostComm_Report_ReadRecords_LastOne||, CODE, READONLY, ALIGN=2

                  HostComm_Report_ReadRecords_LastOne PROC
;;;540    /******************************************************************************/
;;;541    void HostComm_Report_ReadRecords_LastOne(void)
000000  b570              PUSH     {r4-r6,lr}
;;;542    {
;;;543    	uint16 totalPackageLength = SIZE_HEAD_TAIL; /* Include head and tail */
000002  2402              MOVS     r4,#2
;;;544    	uint16 cmdDataLength = 0;
000004  2500              MOVS     r5,#0
;;;545    
;;;546    	totalPackageLength += HostComm_Cmd_Respond_Common(cmdDataLength,
000006  221d              MOVS     r2,#0x1d
000008  21fe              MOVS     r1,#0xfe
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       HostComm_Cmd_Respond_Common
000010  4420              ADD      r0,r0,r4
000012  b284              UXTH     r4,r0
;;;547    			CMD_TYPE_APP, CMD_CODE_APP_READ_RECORD_LASTONE);
;;;548    
;;;549    	/* Send data */
;;;550    	HostComm_SendThrUSB(totalPackageLength, &respBuffer[0]);
000014  4902              LDR      r1,|L28.32|
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       HostComm_SendThrUSB
;;;551    }
00001c  bd70              POP      {r4-r6,pc}
;;;552    #endif
                          ENDP

00001e  0000              DCW      0x0000
                  |L28.32|
                          DCD      respBuffer

                          AREA ||i.HostComm_Send||, CODE, READONLY, ALIGN=1

                  HostComm_Send PROC
;;;975    /******************************************************************************/
;;;976    void HostComm_Send(USART_TypeDef* USARTx, uint8_t *Data,...)
000000  b40f              PUSH     {r0-r3}
;;;977    {
000002  b570              PUSH     {r4-r6,lr}
000004  b086              SUB      sp,sp,#0x18
000006  4606              MOV      r6,r0
;;;978    	const char *s;
;;;979        int d;
;;;980        char buf[16];
;;;981        va_list ap;
;;;982        va_start(ap, Data);
000008  a80c              ADD      r0,sp,#0x30
00000a  9001              STR      r0,[sp,#4]
;;;983    
;;;984    	while(*Data!=0){				                          //end of data string
00000c  e073              B        |L29.246|
                  |L29.14|
;;;985    		if(*Data==0x5c){									  //'\'
00000e  980b              LDR      r0,[sp,#0x2c]
000010  7800              LDRB     r0,[r0,#0]
000012  285c              CMP      r0,#0x5c
000014  d11c              BNE      |L29.80|
;;;986    			switch (*++Data){
000016  980b              LDR      r0,[sp,#0x2c]
000018  1c40              ADDS     r0,r0,#1
00001a  900b              STR      r0,[sp,#0x2c]
00001c  7800              LDRB     r0,[r0,#0]
00001e  286e              CMP      r0,#0x6e
000020  d009              BEQ      |L29.54|
000022  2872              CMP      r0,#0x72
000024  d10f              BNE      |L29.70|
;;;987    				case 'r':							          //enter key
;;;988    					USART_SendData(USARTx, 0x0d);
000026  210d              MOVS     r1,#0xd
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       USART_SendData
;;;989    
;;;990    					Data++;
00002e  980b              LDR      r0,[sp,#0x2c]
000030  1c40              ADDS     r0,r0,#1
000032  900b              STR      r0,[sp,#0x2c]
;;;991    					break;
000034  e00b              B        |L29.78|
                  |L29.54|
;;;992    				case 'n':							          //change line key
;;;993    					USART_SendData(USARTx, 0x0a);
000036  210a              MOVS     r1,#0xa
000038  4630              MOV      r0,r6
00003a  f7fffffe          BL       USART_SendData
;;;994    					Data++;
00003e  980b              LDR      r0,[sp,#0x2c]
000040  1c40              ADDS     r0,r0,#1
000042  900b              STR      r0,[sp,#0x2c]
;;;995    					break;
000044  e003              B        |L29.78|
                  |L29.70|
;;;996    
;;;997    				default:
;;;998    					Data++;
000046  980b              LDR      r0,[sp,#0x2c]
000048  1c40              ADDS     r0,r0,#1
00004a  900b              STR      r0,[sp,#0x2c]
;;;999    				    break;
00004c  bf00              NOP      
                  |L29.78|
00004e  e04b              B        |L29.232|
                  |L29.80|
;;;1000   			}
;;;1001   		}
;;;1002   		else if(*Data=='%'){									  //
000050  980b              LDR      r0,[sp,#0x2c]
000052  7800              LDRB     r0,[r0,#0]
000054  2825              CMP      r0,#0x25
000056  d140              BNE      |L29.218|
;;;1003   			switch (*++Data){
000058  980b              LDR      r0,[sp,#0x2c]
00005a  1c40              ADDS     r0,r0,#1
00005c  900b              STR      r0,[sp,#0x2c]
00005e  7800              LDRB     r0,[r0,#0]
000060  2864              CMP      r0,#0x64
000062  d018              BEQ      |L29.150|
000064  2873              CMP      r0,#0x73
000066  d133              BNE      |L29.208|
;;;1004   				case 's':										  //string
;;;1005                   	s = va_arg(ap, const char *);
000068  9801              LDR      r0,[sp,#4]
00006a  c810              LDM      r0!,{r4}
00006c  9001              STR      r0,[sp,#4]
;;;1006                   	for ( ; *s; s++) {
00006e  e00b              B        |L29.136|
                  |L29.112|
;;;1007                       	USART_SendData(USARTx,*s);
000070  7821              LDRB     r1,[r4,#0]
000072  4630              MOV      r0,r6
000074  f7fffffe          BL       USART_SendData
;;;1008   						while(USART_GetFlagStatus(USARTx, USART_FLAG_TC)==RESET);
000078  bf00              NOP      
                  |L29.122|
00007a  2140              MOVS     r1,#0x40
00007c  4630              MOV      r0,r6
00007e  f7fffffe          BL       USART_GetFlagStatus
000082  2800              CMP      r0,#0
000084  d0f9              BEQ      |L29.122|
000086  1c64              ADDS     r4,r4,#1              ;1006
                  |L29.136|
000088  7820              LDRB     r0,[r4,#0]            ;1006
00008a  2800              CMP      r0,#0                 ;1006
00008c  d1f0              BNE      |L29.112|
;;;1009                   	}
;;;1010   					Data++;
00008e  980b              LDR      r0,[sp,#0x2c]
000090  1c40              ADDS     r0,r0,#1
000092  900b              STR      r0,[sp,#0x2c]
;;;1011                   	break;
000094  e020              B        |L29.216|
                  |L29.150|
;;;1012               	case 'd':										  //decimal
;;;1013                   	d = va_arg(ap, int);
000096  9801              LDR      r0,[sp,#4]
000098  c820              LDM      r0!,{r5}
00009a  9001              STR      r0,[sp,#4]
;;;1014                   	itoa(d, buf, 10);
00009c  220a              MOVS     r2,#0xa
00009e  a902              ADD      r1,sp,#8
0000a0  4628              MOV      r0,r5
0000a2  f7fffffe          BL       itoa
;;;1015                   	for (s = buf; *s; s++) {
0000a6  ac02              ADD      r4,sp,#8
0000a8  e00b              B        |L29.194|
                  |L29.170|
;;;1016                       	USART_SendData(USARTx,*s);
0000aa  7821              LDRB     r1,[r4,#0]
0000ac  4630              MOV      r0,r6
0000ae  f7fffffe          BL       USART_SendData
;;;1017   						while(USART_GetFlagStatus(USARTx, USART_FLAG_TC)==RESET);
0000b2  bf00              NOP      
                  |L29.180|
0000b4  2140              MOVS     r1,#0x40
0000b6  4630              MOV      r0,r6
0000b8  f7fffffe          BL       USART_GetFlagStatus
0000bc  2800              CMP      r0,#0
0000be  d0f9              BEQ      |L29.180|
0000c0  1c64              ADDS     r4,r4,#1              ;1015
                  |L29.194|
0000c2  7820              LDRB     r0,[r4,#0]            ;1015
0000c4  2800              CMP      r0,#0                 ;1015
0000c6  d1f0              BNE      |L29.170|
;;;1018                   	}
;;;1019   					Data++;
0000c8  980b              LDR      r0,[sp,#0x2c]
0000ca  1c40              ADDS     r0,r0,#1
0000cc  900b              STR      r0,[sp,#0x2c]
;;;1020                   	break;
0000ce  e003              B        |L29.216|
                  |L29.208|
;;;1021   				default:
;;;1022   					Data++;
0000d0  980b              LDR      r0,[sp,#0x2c]
0000d2  1c40              ADDS     r0,r0,#1
0000d4  900b              STR      r0,[sp,#0x2c]
;;;1023   				    break;
0000d6  bf00              NOP      
                  |L29.216|
0000d8  e006              B        |L29.232|
                  |L29.218|
;;;1024   			}
;;;1025   		}
;;;1026   		else USART_SendData(USARTx, *Data++);
0000da  980b              LDR      r0,[sp,#0x2c]
0000dc  f8101b01          LDRB     r1,[r0],#1
0000e0  900b              STR      r0,[sp,#0x2c]
0000e2  4630              MOV      r0,r6
0000e4  f7fffffe          BL       USART_SendData
                  |L29.232|
;;;1027   		while(USART_GetFlagStatus(USARTx, USART_FLAG_TC)==RESET);
0000e8  bf00              NOP      
                  |L29.234|
0000ea  2140              MOVS     r1,#0x40
0000ec  4630              MOV      r0,r6
0000ee  f7fffffe          BL       USART_GetFlagStatus
0000f2  2800              CMP      r0,#0
0000f4  d0f9              BEQ      |L29.234|
                  |L29.246|
0000f6  980b              LDR      r0,[sp,#0x2c]         ;984
0000f8  7800              LDRB     r0,[r0,#0]            ;984
0000fa  2800              CMP      r0,#0                 ;984
0000fc  d187              BNE      |L29.14|
;;;1028   	}
;;;1029   }
0000fe  b006              ADD      sp,sp,#0x18
000100  bc70              POP      {r4-r6}
000102  f85dfb14          LDR      pc,[sp],#0x14
;;;1030   
                          ENDP


                          AREA ||i.HostComm_SendResp||, CODE, READONLY, ALIGN=2

                  HostComm_SendResp PROC
;;;945    /******************************************************************************/
;;;946    void HostComm_SendResp(uint8 *Data, uint16 length)
000000  b570              PUSH     {r4-r6,lr}
;;;947    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;948    	while(length-- != 0) {
000006  e00b              B        |L30.32|
                  |L30.8|
;;;949    		USART_SendData(HOSTCOMM_USART, *Data++);
000008  f8141b01          LDRB     r1,[r4],#1
00000c  4807              LDR      r0,|L30.44|
00000e  f7fffffe          BL       USART_SendData
;;;950    		while(USART_GetFlagStatus(HOSTCOMM_USART, USART_FLAG_TC)==RESET);
000012  bf00              NOP      
                  |L30.20|
000014  2140              MOVS     r1,#0x40
000016  4805              LDR      r0,|L30.44|
000018  f7fffffe          BL       USART_GetFlagStatus
00001c  2800              CMP      r0,#0
00001e  d0f9              BEQ      |L30.20|
                  |L30.32|
000020  0028              MOVS     r0,r5                 ;948
000022  f1a50101          SUB      r1,r5,#1              ;948
000026  b28d              UXTH     r5,r1                 ;948
000028  d1ee              BNE      |L30.8|
;;;951    	}
;;;952    }
00002a  bd70              POP      {r4-r6,pc}
;;;953    
                          ENDP

                  |L30.44|
                          DCD      0x40004400

                          AREA ||i.HostComm_SendThrUSB||, CODE, READONLY, ALIGN=2

                  HostComm_SendThrUSB PROC
;;;165    /******************************************************************************/
;;;166    void HostComm_SendThrUSB(uint16 len, uint8 *srcPtr)
000000  b570              PUSH     {r4-r6,lr}
;;;167    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;168    	TxData.len = len;
000006  4805              LDR      r0,|L31.28|
000008  8004              STRH     r4,[r0,#0]
;;;169    	memcpy(TxData.Data, srcPtr, len);
00000a  4622              MOV      r2,r4
00000c  4629              MOV      r1,r5
00000e  1c80              ADDS     r0,r0,#2
000010  f7fffffe          BL       __aeabi_memcpy
;;;170    	Comm_RequestTX = 1;
000014  2001              MOVS     r0,#1
000016  4902              LDR      r1,|L31.32|
000018  7008              STRB     r0,[r1,#0]
;;;171    }
00001a  bd70              POP      {r4-r6,pc}
;;;172    
                          ENDP

                  |L31.28|
                          DCD      TxData
                  |L31.32|
                          DCD      Comm_RequestTX

                          AREA ||i.HostComm_Send_Char||, CODE, READONLY, ALIGN=2

                  HostComm_Send_Char PROC
;;;954    /******************************************************************************/
;;;955    void HostComm_Send_Char(u8 data)
000000  b510              PUSH     {r4,lr}
;;;956    {
000002  4604              MOV      r4,r0
;;;957    	/* Send one byte through HOSTCOMM_USART */
;;;958    	USART_SendData(HOSTCOMM_USART, (u8) data);
000004  4621              MOV      r1,r4
000006  4805              LDR      r0,|L32.28|
000008  f7fffffe          BL       USART_SendData
;;;959    	/* Wait while HOSTCOMM_USART TXE = 0 */
;;;960    	while(USART_GetFlagStatus(HOSTCOMM_USART, USART_FLAG_TXE) == RESET)
00000c  bf00              NOP      
                  |L32.14|
00000e  2180              MOVS     r1,#0x80
000010  4802              LDR      r0,|L32.28|
000012  f7fffffe          BL       USART_GetFlagStatus
000016  2800              CMP      r0,#0
000018  d0f9              BEQ      |L32.14|
;;;961    	{
;;;962    	}
;;;963    }
00001a  bd10              POP      {r4,pc}
;;;964    
                          ENDP

                  |L32.28|
                          DCD      0x40004400

                          AREA ||i.HostComm_Send_LIS||, CODE, READONLY, ALIGN=1

                  HostComm_Send_LIS PROC
;;;152    /******************************************************************************/
;;;153    void HostComm_Send_LIS(uint8 *data)
000000  b570              PUSH     {r4-r6,lr}
;;;154    {
000002  4604              MOV      r4,r0
;;;155    	uint8 i=0;
000004  2500              MOVS     r5,#0
;;;156    	while(*(data+i)!='\0')
000006  e001              B        |L33.12|
                  |L33.8|
;;;157    	{
;;;158    		i++;
000008  1c68              ADDS     r0,r5,#1
00000a  b2c5              UXTB     r5,r0
                  |L33.12|
00000c  5d60              LDRB     r0,[r4,r5]            ;156
00000e  2800              CMP      r0,#0                 ;156
000010  d1fa              BNE      |L33.8|
;;;159    	}
;;;160    	HostComm_SendThrUSB(i,data);
000012  4621              MOV      r1,r4
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       HostComm_SendThrUSB
;;;161    
;;;162    	Delay_ms_SW(5);
00001a  2005              MOVS     r0,#5
00001c  f7fffffe          BL       Delay_ms_SW
;;;163    }
000020  bd70              POP      {r4-r6,pc}
;;;164    
                          ENDP


                          AREA ||i.HostComm_Send_String||, CODE, READONLY, ALIGN=1

                  HostComm_Send_String PROC
;;;965    /******************************************************************************/
;;;966    void HostComm_Send_String(u8 *strPtr)
000000  b510              PUSH     {r4,lr}
;;;967    {
000002  4604              MOV      r4,r0
;;;968    	while(*strPtr)
000004  e003              B        |L34.14|
                  |L34.6|
;;;969    	{
;;;970    		HostComm_Send_Char(*strPtr);
000006  7820              LDRB     r0,[r4,#0]
000008  f7fffffe          BL       HostComm_Send_Char
;;;971    		strPtr++;
00000c  1c64              ADDS     r4,r4,#1
                  |L34.14|
00000e  7820              LDRB     r0,[r4,#0]            ;968
000010  2800              CMP      r0,#0                 ;968
000012  d1f8              BNE      |L34.6|
;;;972    	}
;;;973    }
000014  bd10              POP      {r4,pc}
;;;974    
                          ENDP


                          AREA ||i.LoByte||, CODE, READONLY, ALIGN=1

                  LoByte PROC
;;;287    /******************************************************************************/
;;;288    static uint8 LoByte(uint16 value)
000000  4601              MOV      r1,r0
;;;289    {
;;;290    	return (uint8)(value & 0x00FF);
000002  b2c8              UXTB     r0,r1
;;;291    }
000004  4770              BX       lr
;;;292    
                          ENDP


                          AREA ||i.USART2_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART2_IRQHandler PROC
;;;898    ******************************************************************************/
;;;899    void USART2_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;900    {
;;;901    	uint8 value;
;;;902    	if(USART_GetITStatus(HOSTCOMM_USART, USART_IT_RXNE) != RESET)
000002  f2405125          MOV      r1,#0x525
000006  482d              LDR      r0,|L36.188|
000008  f7fffffe          BL       USART_GetITStatus
00000c  2800              CMP      r0,#0
00000e  d053              BEQ      |L36.184|
;;;903    	{
;;;904    		value=USART_ReceiveData(HOSTCOMM_USART);
000010  482a              LDR      r0,|L36.188|
000012  f7fffffe          BL       USART_ReceiveData
000016  b2c4              UXTB     r4,r0
;;;905    
;;;906    		if ((value == '$') && (contReceive == 0))
000018  2c24              CMP      r4,#0x24
00001a  d111              BNE      |L36.64|
00001c  4828              LDR      r0,|L36.192|
00001e  7800              LDRB     r0,[r0,#0]  ; contReceive
000020  b970              CBNZ     r0,|L36.64|
;;;907    		{
;;;908    			contReceive = 1;
000022  2001              MOVS     r0,#1
000024  4926              LDR      r1,|L36.192|
000026  7008              STRB     r0,[r1,#0]
;;;909    			recCount = 0;
000028  2000              MOVS     r0,#0
00002a  4926              LDR      r1,|L36.196|
00002c  8008              STRH     r0,[r1,#0]
;;;910    			recBuffer[recCount++] = value;
00002e  4608              MOV      r0,r1
000030  8801              LDRH     r1,[r0,#0]  ; recCount
000032  8800              LDRH     r0,[r0,#0]  ; recCount
000034  1c40              ADDS     r0,r0,#1
000036  4a23              LDR      r2,|L36.196|
000038  8010              STRH     r0,[r2,#0]
00003a  4823              LDR      r0,|L36.200|
00003c  5444              STRB     r4,[r0,r1]
00003e  e007              B        |L36.80|
                  |L36.64|
;;;911    		}
;;;912    		else
;;;913    		{
;;;914    			recBuffer[recCount++] = value;
000040  4820              LDR      r0,|L36.196|
000042  8801              LDRH     r1,[r0,#0]  ; recCount
000044  8800              LDRH     r0,[r0,#0]  ; recCount
000046  1c40              ADDS     r0,r0,#1
000048  4a1e              LDR      r2,|L36.196|
00004a  8010              STRH     r0,[r2,#0]
00004c  481e              LDR      r0,|L36.200|
00004e  5444              STRB     r4,[r0,r1]
                  |L36.80|
;;;915    		}
;;;916    
;;;917    		/* Get the package length: header + data + tail */
;;;918    		if (recCount >= SIZE_HEAD_LEN)
000050  481c              LDR      r0,|L36.196|
000052  8800              LDRH     r0,[r0,#0]  ; recCount
000054  2803              CMP      r0,#3
000056  db09              BLT      |L36.108|
;;;919    		{
;;;920    			respLength =
000058  481b              LDR      r0,|L36.200|
00005a  7840              LDRB     r0,[r0,#1]  ; recBuffer
00005c  491a              LDR      r1,|L36.200|
00005e  7889              LDRB     r1,[r1,#2]  ; recBuffer
000060  ea402001          ORR      r0,r0,r1,LSL #8
000064  1c80              ADDS     r0,r0,#2
000066  4919              LDR      r1,|L36.204|
000068  8008              STRH     r0,[r1,#0]
00006a  e002              B        |L36.114|
                  |L36.108|
;;;921    					(recBuffer[OFFSET_LEN_LO] | (recBuffer[OFFSET_LEN_HI] << 8))
;;;922    					+ SIZE_HEAD_TAIL;
;;;923    		}
;;;924    		else
;;;925    		{
;;;926    			respLength = 0;
00006c  2000              MOVS     r0,#0
00006e  4917              LDR      r1,|L36.204|
000070  8008              STRH     r0,[r1,#0]
                  |L36.114|
;;;927    		}
;;;928    
;;;929    		/* Receive all: start processing response data */
;;;930    		if ((respLength > 0) && (recCount >= respLength))
000072  4816              LDR      r0,|L36.204|
000074  8800              LDRH     r0,[r0,#0]  ; respLength
000076  2800              CMP      r0,#0
000078  dd1e              BLE      |L36.184|
00007a  4812              LDR      r0,|L36.196|
00007c  8800              LDRH     r0,[r0,#0]  ; recCount
00007e  4913              LDR      r1,|L36.204|
000080  8809              LDRH     r1,[r1,#0]  ; respLength
000082  4288              CMP      r0,r1
000084  db18              BLT      |L36.184|
;;;931    		{
;;;932    			HostComm_RecBufAvailable = 1;
000086  2001              MOVS     r0,#1
000088  4911              LDR      r1,|L36.208|
00008a  7008              STRB     r0,[r1,#0]
;;;933    			HostComm_RecBufSize = recCount;
00008c  480d              LDR      r0,|L36.196|
00008e  8800              LDRH     r0,[r0,#0]  ; recCount
000090  4910              LDR      r1,|L36.212|
000092  8008              STRH     r0,[r1,#0]
;;;934    
;;;935    			memcpy(cmdBuffer, recBuffer, recCount);
000094  480b              LDR      r0,|L36.196|
000096  8802              LDRH     r2,[r0,#0]  ; recCount
000098  490b              LDR      r1,|L36.200|
00009a  480f              LDR      r0,|L36.216|
00009c  f7fffffe          BL       __aeabi_memcpy
;;;936    			memset(recBuffer, 0, recCount);
0000a0  4808              LDR      r0,|L36.196|
0000a2  8801              LDRH     r1,[r0,#0]  ; recCount
0000a4  4808              LDR      r0,|L36.200|
0000a6  f7fffffe          BL       __aeabi_memclr
;;;937    
;;;938    			contReceive = 0;
0000aa  2000              MOVS     r0,#0
0000ac  4904              LDR      r1,|L36.192|
0000ae  7008              STRB     r0,[r1,#0]
;;;939    			respLength = 0;
0000b0  4906              LDR      r1,|L36.204|
0000b2  8008              STRH     r0,[r1,#0]
;;;940    			recCount = 0;
0000b4  4903              LDR      r1,|L36.196|
0000b6  8008              STRH     r0,[r1,#0]
                  |L36.184|
;;;941    		}
;;;942    	}
;;;943    }
0000b8  bd10              POP      {r4,pc}
;;;944    
                          ENDP

0000ba  0000              DCW      0x0000
                  |L36.188|
                          DCD      0x40004400
                  |L36.192|
                          DCD      contReceive
                  |L36.196|
                          DCD      recCount
                  |L36.200|
                          DCD      recBuffer
                  |L36.204|
                          DCD      respLength
                  |L36.208|
                          DCD      HostComm_RecBufAvailable
                  |L36.212|
                          DCD      HostComm_RecBufSize
                  |L36.216|
                          DCD      cmdBuffer

                          AREA ||i.itoa||, CODE, READONLY, ALIGN=2

                  itoa PROC
;;;1031   /******************************************************************************/
;;;1032   char *itoa(int32 value, char *string, int radix)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1033   {
000002  4603              MOV      r3,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;1034       int     i, d;
;;;1035       int     flag = 0;
000008  2700              MOVS     r7,#0
;;;1036       char    *ptr = string;
00000a  4629              MOV      r1,r5
;;;1037   
;;;1038       /* This implementation only works for decimal numbers. */
;;;1039       if (radix != 10)
00000c  2e0a              CMP      r6,#0xa
00000e  d003              BEQ      |L37.24|
;;;1040       {
;;;1041           *ptr = 0;
000010  2000              MOVS     r0,#0
000012  7008              STRB     r0,[r1,#0]
;;;1042           return string;
000014  4628              MOV      r0,r5
                  |L37.22|
;;;1043       }
;;;1044   
;;;1045       if (!value)
;;;1046       {
;;;1047           *ptr++ = 0x30;
;;;1048           *ptr = 0;
;;;1049           return string;
;;;1050       }
;;;1051   
;;;1052       /* if this is a negative value insert the minus sign. */
;;;1053       if (value < 0)
;;;1054       {
;;;1055           *ptr++ = '-';
;;;1056   
;;;1057           /* Make the value positive. */
;;;1058           value *= -1;
;;;1059       }
;;;1060   
;;;1061       for (i = 1000000000; i > 0; i /= 10)
;;;1062       {
;;;1063           d = value / i;
;;;1064   
;;;1065           if (d || flag)
;;;1066           {
;;;1067               *ptr++ = (char)(d + 0x30);
;;;1068               value -= (d * i);
;;;1069               flag = 1;
;;;1070           }
;;;1071       }
;;;1072   
;;;1073       /* Null terminate the string. */
;;;1074       *ptr = 0;
;;;1075   
;;;1076       return string;
;;;1077   
;;;1078   } /* NCL_Itoa */
000016  bdf0              POP      {r4-r7,pc}
                  |L37.24|
000018  b933              CBNZ     r3,|L37.40|
00001a  2030              MOVS     r0,#0x30              ;1047
00001c  f8010b01          STRB     r0,[r1],#1            ;1047
000020  2000              MOVS     r0,#0                 ;1048
000022  7008              STRB     r0,[r1,#0]            ;1048
000024  4628              MOV      r0,r5                 ;1049
000026  e7f6              B        |L37.22|
                  |L37.40|
000028  2b00              CMP      r3,#0                 ;1053
00002a  da03              BGE      |L37.52|
00002c  202d              MOVS     r0,#0x2d              ;1055
00002e  f8010b01          STRB     r0,[r1],#1            ;1055
000032  425b              RSBS     r3,r3,#0              ;1058
                  |L37.52|
000034  4a0a              LDR      r2,|L37.96|
000036  e00d              B        |L37.84|
                  |L37.56|
000038  fb93f4f2          SDIV     r4,r3,r2              ;1063
00003c  b904              CBNZ     r4,|L37.64|
00003e  b137              CBZ      r7,|L37.78|
                  |L37.64|
000040  f1040030          ADD      r0,r4,#0x30           ;1067
000044  f8010b01          STRB     r0,[r1],#1            ;1067
000048  fb043312          MLS      r3,r4,r2,r3           ;1068
00004c  2701              MOVS     r7,#1                 ;1069
                  |L37.78|
00004e  200a              MOVS     r0,#0xa               ;1061
000050  fb92f2f0          SDIV     r2,r2,r0              ;1061
                  |L37.84|
000054  2a00              CMP      r2,#0                 ;1061
000056  dcef              BGT      |L37.56|
000058  2000              MOVS     r0,#0                 ;1074
00005a  7008              STRB     r0,[r1,#0]            ;1074
00005c  4628              MOV      r0,r5                 ;1076
00005e  e7da              B        |L37.22|
                          ENDP

                  |L37.96|
                          DCD      0x3b9aca00

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  recBuffer
                          %        3072
                  cmdBuffer
                          %        2148
                  respBuffer
                          %        100

                          AREA ||.data||, DATA, ALIGN=2

                  HostComm_RecBufAvailable
000000  00                DCB      0x00
                  contReceive
000001  00                DCB      0x00
                  recCount
000002  0000              DCW      0x0000
                  respLength
000004  0000              DCW      0x0000
                  keyMatched
000006  0000              DCB      0x00,0x00
                  HostComm_RecBufSize
000008  0000              DCB      0x00,0x00
                  cmdLength
00000a  0000              DCB      0x00,0x00
                  cmdType
00000c  00                DCB      0x00
                  cmdCode
00000d  000000            DCB      0x00,0x00,0x00
                  binFileAttr_Input
                          %        8
