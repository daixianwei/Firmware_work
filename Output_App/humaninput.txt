; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\Output_App\humaninput.o --asm_dir=..\Output_App\ --list_dir=..\Output_App\ --depend=..\Output_App\humaninput.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=870 -I.\System\CM3 -I.\System\FWlib\inc -I.\System\Startup -I.\ISR -I.\Main -I.\Management\DisplayDriver -I.\Management\HumanInput -I.\Management\Interface -I.\Management\RotationMotor -I.\Management\ScanMotor -I.\Management\Common_CRC -I.\Management\QRCode -I.\Management\SystemManage_RTC -I.\Management\SignalProcess_Sample -I.\USB -I.\USB\comm -I.\USB\lib -I.\USB\src -I.\USB\USB_Communication -ID:\Keil4.0\ARM\RV31\Inc -ID:\Keil4.0\ARM\CMSIS\Include -ID:\Keil4.0\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DUSE_STM3210E_EVAL -W --omf_browse=..\Output_App\humaninput.crf Management\HumanInput\HumanInput.c]
                          THUMB

                          AREA ||i.EXTIX_Init||, CODE, READONLY, ALIGN=1

                  EXTIX_Init PROC
;;;45     *******************************************************************************/
;;;46     void EXTIX_Init(void)
000000  b50e              PUSH     {r1-r3,lr}
;;;47     {
;;;48     	EXTI_InitTypeDef EXTI_InitStructure;
;;;49     	NVIC_InitTypeDef NVIC_InitStructure;
;;;50     
;;;51     	//GPIOB.4	  中断线以及中断初始化配置 上升沿触发
;;;52     	GPIO_EXTILineConfig(GPIO_PortSourceGPIOB,GPIO_PinSource4);
000002  2104              MOVS     r1,#4
000004  2001              MOVS     r0,#1
000006  f7fffffe          BL       GPIO_EXTILineConfig
;;;53     
;;;54     	EXTI_InitStructure.EXTI_Line = EXTI_Line4;  				//中间确认按钮
00000a  2010              MOVS     r0,#0x10
00000c  9001              STR      r0,[sp,#4]
;;;55     	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
00000e  2000              MOVS     r0,#0
000010  f88d0008          STRB     r0,[sp,#8]
;;;56     	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
000014  200c              MOVS     r0,#0xc
000016  f88d0009          STRB     r0,[sp,#9]
;;;57     	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
00001a  2001              MOVS     r0,#1
00001c  f88d000a          STRB     r0,[sp,#0xa]
;;;58     	EXTI_Init(&EXTI_InitStructure);
000020  a801              ADD      r0,sp,#4
000022  f7fffffe          BL       EXTI_Init
;;;59     
;;;60     	//GPIOD.8 中断线以及中断初始化配置   上升沿触发
;;;61     	GPIO_EXTILineConfig(GPIO_PortSourceGPIOD,GPIO_PinSource8);
000026  2108              MOVS     r1,#8
000028  2003              MOVS     r0,#3
00002a  f7fffffe          BL       GPIO_EXTILineConfig
;;;62     
;;;63     	EXTI_InitStructure.EXTI_Line = EXTI_Line8;					//向右按钮
00002e  f44f7080          MOV      r0,#0x100
000032  9001              STR      r0,[sp,#4]
;;;64     	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
000034  2000              MOVS     r0,#0
000036  f88d0008          STRB     r0,[sp,#8]
;;;65     	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
00003a  200c              MOVS     r0,#0xc
00003c  f88d0009          STRB     r0,[sp,#9]
;;;66     	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
000040  2001              MOVS     r0,#1
000042  f88d000a          STRB     r0,[sp,#0xa]
;;;67     	EXTI_Init(&EXTI_InitStructure);
000046  a801              ADD      r0,sp,#4
000048  f7fffffe          BL       EXTI_Init
;;;68     
;;;69     	//GPIOD.9	  中断线以及中断初始化配置  上升沿触发
;;;70     	GPIO_EXTILineConfig(GPIO_PortSourceGPIOD,GPIO_PinSource9);
00004c  2109              MOVS     r1,#9
00004e  2003              MOVS     r0,#3
000050  f7fffffe          BL       GPIO_EXTILineConfig
;;;71     
;;;72     	EXTI_InitStructure.EXTI_Line = EXTI_Line9;					//向左按钮
000054  f44f7000          MOV      r0,#0x200
000058  9001              STR      r0,[sp,#4]
;;;73     	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
00005a  2000              MOVS     r0,#0
00005c  f88d0008          STRB     r0,[sp,#8]
;;;74     	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
000060  200c              MOVS     r0,#0xc
000062  f88d0009          STRB     r0,[sp,#9]
;;;75     	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
000066  2001              MOVS     r0,#1
000068  f88d000a          STRB     r0,[sp,#0xa]
;;;76     	EXTI_Init(&EXTI_InitStructure);
00006c  a801              ADD      r0,sp,#4
00006e  f7fffffe          BL       EXTI_Init
;;;77     
;;;78     	NVIC_InitStructure.NVIC_IRQChannel = EXTI4_IRQn;
000072  200a              MOVS     r0,#0xa
000074  f88d0000          STRB     r0,[sp,#0]
;;;79     	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02;	//抢占优先级2
000078  2002              MOVS     r0,#2
00007a  f88d0001          STRB     r0,[sp,#1]
;;;80     	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x01;			//子优先级1
00007e  2001              MOVS     r0,#1
000080  f88d0002          STRB     r0,[sp,#2]
;;;81     	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;					//使能外部中断通道
000084  f88d0003          STRB     r0,[sp,#3]
;;;82     	NVIC_Init(&NVIC_InitStructure);
000088  4668              MOV      r0,sp
00008a  f7fffffe          BL       NVIC_Init
;;;83     
;;;84     	NVIC_InitStructure.NVIC_IRQChannel = EXTI9_5_IRQn ;
00008e  2017              MOVS     r0,#0x17
000090  f88d0000          STRB     r0,[sp,#0]
;;;85     	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02;	//抢占优先级2
000094  2002              MOVS     r0,#2
000096  f88d0001          STRB     r0,[sp,#1]
;;;86     	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x00;			//子优先级0
00009a  2000              MOVS     r0,#0
00009c  f88d0002          STRB     r0,[sp,#2]
;;;87     	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;					//使能外部中断通道
0000a0  2001              MOVS     r0,#1
0000a2  f88d0003          STRB     r0,[sp,#3]
;;;88     
;;;89     	NVIC_Init(&NVIC_InitStructure);
0000a6  4668              MOV      r0,sp
0000a8  f7fffffe          BL       NVIC_Init
;;;90     }
0000ac  bd0e              POP      {r1-r3,pc}
;;;91     
                          ENDP


                          AREA ||i.EXTI_Key_Confirm_Disable||, CODE, READONLY, ALIGN=1

                  EXTI_Key_Confirm_Disable PROC
;;;92     /******************************************************************************/
;;;93     void EXTI_Key_Confirm_Disable(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;94     {
;;;95     	EXTI_InitTypeDef EXTI_InitStructure;
;;;96     
;;;97     	//GPIOB.4	  中断线以及中断初始化配置 上升沿触发
;;;98     	GPIO_EXTILineConfig(GPIO_PortSourceGPIOB,GPIO_PinSource4);
000002  2104              MOVS     r1,#4
000004  2001              MOVS     r0,#1
000006  f7fffffe          BL       GPIO_EXTILineConfig
;;;99     
;;;100    	EXTI_InitStructure.EXTI_Line = EXTI_Line4;  				//中间确认按钮
00000a  2010              MOVS     r0,#0x10
00000c  9000              STR      r0,[sp,#0]
;;;101    	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
00000e  2000              MOVS     r0,#0
000010  f88d0004          STRB     r0,[sp,#4]
;;;102    	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
000014  200c              MOVS     r0,#0xc
000016  f88d0005          STRB     r0,[sp,#5]
;;;103    	EXTI_InitStructure.EXTI_LineCmd = DISABLE;
00001a  2000              MOVS     r0,#0
00001c  f88d0006          STRB     r0,[sp,#6]
;;;104    	EXTI_Init(&EXTI_InitStructure);
000020  4668              MOV      r0,sp
000022  f7fffffe          BL       EXTI_Init
;;;105    }
000026  bd1c              POP      {r2-r4,pc}
;;;106    
                          ENDP


                          AREA ||i.EXTI_Key_Confirm_Enable||, CODE, READONLY, ALIGN=1

                  EXTI_Key_Confirm_Enable PROC
;;;107    /******************************************************************************/
;;;108    void EXTI_Key_Confirm_Enable(void)
000000  b50e              PUSH     {r1-r3,lr}
;;;109    {
;;;110    	EXTI_InitTypeDef EXTI_InitStructure;
;;;111    	NVIC_InitTypeDef NVIC_InitStructure;
;;;112    
;;;113    	//GPIOB.4	  中断线以及中断初始化配置 上升沿触发
;;;114    	GPIO_EXTILineConfig(GPIO_PortSourceGPIOB,GPIO_PinSource4);
000002  2104              MOVS     r1,#4
000004  2001              MOVS     r0,#1
000006  f7fffffe          BL       GPIO_EXTILineConfig
;;;115    
;;;116    	EXTI_InitStructure.EXTI_Line = EXTI_Line4;  				//中间确认按钮
00000a  2010              MOVS     r0,#0x10
00000c  9001              STR      r0,[sp,#4]
;;;117    	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
00000e  2000              MOVS     r0,#0
000010  f88d0008          STRB     r0,[sp,#8]
;;;118    	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
000014  200c              MOVS     r0,#0xc
000016  f88d0009          STRB     r0,[sp,#9]
;;;119    	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
00001a  2001              MOVS     r0,#1
00001c  f88d000a          STRB     r0,[sp,#0xa]
;;;120    	EXTI_Init(&EXTI_InitStructure);
000020  a801              ADD      r0,sp,#4
000022  f7fffffe          BL       EXTI_Init
;;;121    
;;;122    	NVIC_InitStructure.NVIC_IRQChannel = EXTI4_IRQn;
000026  200a              MOVS     r0,#0xa
000028  f88d0000          STRB     r0,[sp,#0]
;;;123    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02;	//抢占优先级2
00002c  2002              MOVS     r0,#2
00002e  f88d0001          STRB     r0,[sp,#1]
;;;124    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x01;			//子优先级1
000032  2001              MOVS     r0,#1
000034  f88d0002          STRB     r0,[sp,#2]
;;;125    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;					//使能外部中断通道
000038  f88d0003          STRB     r0,[sp,#3]
;;;126    	NVIC_Init(&NVIC_InitStructure);
00003c  4668              MOV      r0,sp
00003e  f7fffffe          BL       NVIC_Init
;;;127    }
000042  bd0e              POP      {r1-r3,pc}
;;;128    
                          ENDP


                          AREA ||i.HumanInput_Init||, CODE, READONLY, ALIGN=2

                  HumanInput_Init PROC
;;;22     *******************************************************************************/
;;;23     void HumanInput_Init(void)
000000  b508              PUSH     {r3,lr}
;;;24     {
;;;25     	GPIO_InitTypeDef GPIO_InitStructure;
;;;26     
;;;27     	GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_8|GPIO_Pin_9;
000002  f44f7040          MOV      r0,#0x300
000006  f8ad0000          STRH     r0,[sp,#0]
;;;28     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; 		//设置成上拉输入
00000a  2048              MOVS     r0,#0x48
00000c  f88d0003          STRB     r0,[sp,#3]
;;;29     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000010  2003              MOVS     r0,#3
000012  f88d0002          STRB     r0,[sp,#2]
;;;30     	GPIO_Init(GPIOD, &GPIO_InitStructure);				//初始化GPIOE2,3,4
000016  4669              MOV      r1,sp
000018  4808              LDR      r0,|L4.60|
00001a  f7fffffe          BL       GPIO_Init
;;;31     
;;;32     	//初始化 WK_UP-->GPIOA.0	  下拉输入
;;;33     	GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_4;
00001e  2010              MOVS     r0,#0x10
000020  f8ad0000          STRH     r0,[sp,#0]
;;;34     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; 		//PA0设置成输入，默认下拉
000024  2048              MOVS     r0,#0x48
000026  f88d0003          STRB     r0,[sp,#3]
;;;35     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00002a  2003              MOVS     r0,#3
00002c  f88d0002          STRB     r0,[sp,#2]
;;;36     	GPIO_Init(GPIOB, &GPIO_InitStructure);				//初始化GPIOA.0
000030  4669              MOV      r1,sp
000032  4803              LDR      r0,|L4.64|
000034  f7fffffe          BL       GPIO_Init
;;;37     }
000038  bd08              POP      {r3,pc}
;;;38     
                          ENDP

00003a  0000              DCW      0x0000
                  |L4.60|
                          DCD      0x40011400
                  |L4.64|
                          DCD      0x40010c00

                          AREA ||i.Key_Confirm||, CODE, READONLY, ALIGN=2

                  Key_Confirm PROC
;;;135    *******************************************************************************/
;;;136    void Key_Confirm(void)
000000  b510              PUSH     {r4,lr}
;;;137    {
;;;138    	if(Exti_lock)
000002  480f              LDR      r0,|L5.64|
000004  7800              LDRB     r0,[r0,#0]  ; Exti_lock
000006  b1d0              CBZ      r0,|L5.62|
;;;139    	{
;;;140    		if(short_key_flag)
000008  480e              LDR      r0,|L5.68|
00000a  7800              LDRB     r0,[r0,#0]  ; short_key_flag
00000c  b148              CBZ      r0,|L5.34|
;;;141    		{
;;;142    			key_state_confirm = ENABLE;
00000e  2001              MOVS     r0,#1
000010  490d              LDR      r1,|L5.72|
000012  7008              STRB     r0,[r1,#0]
;;;143    			key_state = ENABLE;
000014  490d              LDR      r1,|L5.76|
000016  7008              STRB     r0,[r1,#0]
;;;144    			short_key_flag = 0;
000018  2000              MOVS     r0,#0
00001a  490a              LDR      r1,|L5.68|
00001c  7008              STRB     r0,[r1,#0]
;;;145    			EXTI_Key_Confirm_Enable();
00001e  f7fffffe          BL       EXTI_Key_Confirm_Enable
                  |L5.34|
;;;146    		}
;;;147    
;;;148    		if(UI_state != UI_STATE_TESTING && Power_Open && long_key_flag)
000022  480b              LDR      r0,|L5.80|
000024  7800              LDRB     r0,[r0,#0]  ; UI_state
000026  2808              CMP      r0,#8
000028  d007              BEQ      |L5.58|
00002a  480a              LDR      r0,|L5.84|
00002c  7800              LDRB     r0,[r0,#0]  ; Power_Open
00002e  b120              CBZ      r0,|L5.58|
000030  4809              LDR      r0,|L5.88|
000032  7800              LDRB     r0,[r0,#0]  ; long_key_flag
000034  b108              CBZ      r0,|L5.58|
;;;149    		{
;;;150    			SystemManage_CheckPowerOff();
000036  f7fffffe          BL       SystemManage_CheckPowerOff
                  |L5.58|
;;;151    		}
;;;152    
;;;153    //		if(UI_state == UI_STATE_RESULT && UI_state == UI_STATE_RESULT_2 &&
;;;154    //				long_key_flag)
;;;155    //		{
;;;156    //			long_key_flag = 0;
;;;157    		EXTI_Key_Confirm_Enable();
00003a  f7fffffe          BL       EXTI_Key_Confirm_Enable
                  |L5.62|
;;;158    //		}
;;;159    	}
;;;160    }
00003e  bd10              POP      {r4,pc}
;;;161    
                          ENDP

                  |L5.64|
                          DCD      Exti_lock
                  |L5.68|
                          DCD      short_key_flag
                  |L5.72|
                          DCD      key_state_confirm
                  |L5.76|
                          DCD      key_state
                  |L5.80|
                          DCD      UI_state
                  |L5.84|
                          DCD      Power_Open
                  |L5.88|
                          DCD      long_key_flag

                          AREA ||i.Key_Left||, CODE, READONLY, ALIGN=2

                  Key_Left PROC
;;;194    /******************************************************************************/
;;;195    void Key_Left(void)
000000  481a              LDR      r0,|L6.108|
;;;196    {
;;;197    	switch(Interface_Key)
000002  7800              LDRB     r0,[r0,#0]  ; Interface_Key
000004  b130              CBZ      r0,|L6.20|
000006  2801              CMP      r0,#1
000008  d018              BEQ      |L6.60|
00000a  2802              CMP      r0,#2
00000c  d017              BEQ      |L6.62|
00000e  2803              CMP      r0,#3
000010  d129              BNE      |L6.102|
000012  e01e              B        |L6.82|
                  |L6.20|
;;;198    	{
;;;199    		case 0:
;;;200    			key_state = 1;
000014  2001              MOVS     r0,#1
000016  4916              LDR      r1,|L6.112|
000018  7008              STRB     r0,[r1,#0]
;;;201    			key_state_confirm = 0;
00001a  2000              MOVS     r0,#0
00001c  4915              LDR      r1,|L6.116|
00001e  7008              STRB     r0,[r1,#0]
;;;202    			if(Key_control > 1)
000020  4815              LDR      r0,|L6.120|
000022  7800              LDRB     r0,[r0,#0]  ; Key_control
000024  2801              CMP      r0,#1
000026  dd05              BLE      |L6.52|
;;;203    			{
;;;204    				Key_control -= 1;
000028  4813              LDR      r0,|L6.120|
00002a  7800              LDRB     r0,[r0,#0]  ; Key_control
00002c  1e40              SUBS     r0,r0,#1
00002e  4912              LDR      r1,|L6.120|
000030  7008              STRB     r0,[r1,#0]
000032  e002              B        |L6.58|
                  |L6.52|
;;;205    			}
;;;206    			else
;;;207    			{
;;;208    				Key_control = 4;
000034  2004              MOVS     r0,#4
000036  4910              LDR      r1,|L6.120|
000038  7008              STRB     r0,[r1,#0]
                  |L6.58|
;;;209    			}
;;;210    		break;
00003a  e015              B        |L6.104|
                  |L6.60|
;;;211    
;;;212    		case 1:
;;;213    		break;
00003c  e014              B        |L6.104|
                  |L6.62|
;;;214    
;;;215    		case 2:
;;;216    			key_state = ENABLE;
00003e  2001              MOVS     r0,#1
000040  490b              LDR      r1,|L6.112|
000042  7008              STRB     r0,[r1,#0]
;;;217    			key_state_confirm = 0;
000044  2000              MOVS     r0,#0
000046  490b              LDR      r1,|L6.116|
000048  7008              STRB     r0,[r1,#0]
;;;218    			Key_control = 1;
00004a  2001              MOVS     r0,#1
00004c  490a              LDR      r1,|L6.120|
00004e  7008              STRB     r0,[r1,#0]
;;;219    		break;
000050  e00a              B        |L6.104|
                  |L6.82|
;;;220    
;;;221    		case 3:
;;;222    			key_state = ENABLE;
000052  2001              MOVS     r0,#1
000054  4906              LDR      r1,|L6.112|
000056  7008              STRB     r0,[r1,#0]
;;;223    			key_state_confirm = 0;
000058  2000              MOVS     r0,#0
00005a  4906              LDR      r1,|L6.116|
00005c  7008              STRB     r0,[r1,#0]
;;;224    			Key_control = 1;
00005e  2001              MOVS     r0,#1
000060  4905              LDR      r1,|L6.120|
000062  7008              STRB     r0,[r1,#0]
;;;225    		break;
000064  e000              B        |L6.104|
                  |L6.102|
;;;226    
;;;227    		default:
;;;228    		break;
000066  bf00              NOP      
                  |L6.104|
000068  bf00              NOP                            ;210
;;;229    	}
;;;230    }
00006a  4770              BX       lr
;;;231    
                          ENDP

                  |L6.108|
                          DCD      Interface_Key
                  |L6.112|
                          DCD      key_state
                  |L6.116|
                          DCD      key_state_confirm
                  |L6.120|
                          DCD      Key_control

                          AREA ||i.Key_Right||, CODE, READONLY, ALIGN=2

                  Key_Right PROC
;;;162    /******************************************************************************/
;;;163    void Key_Right(void)
000000  4814              LDR      r0,|L7.84|
;;;164    {
;;;165    	switch(Interface_Key)
000002  7800              LDRB     r0,[r0,#0]  ; Interface_Key
000004  b120              CBZ      r0,|L7.16|
000006  2801              CMP      r0,#1
000008  d016              BEQ      |L7.56|
00000a  2802              CMP      r0,#2
00000c  d11f              BNE      |L7.78|
00000e  e014              B        |L7.58|
                  |L7.16|
;;;166    	{
;;;167    		case 0:
;;;168    			key_state = ENABLE;
000010  2001              MOVS     r0,#1
000012  4911              LDR      r1,|L7.88|
000014  7008              STRB     r0,[r1,#0]
;;;169    			key_state_confirm = 0;
000016  2000              MOVS     r0,#0
000018  4910              LDR      r1,|L7.92|
00001a  7008              STRB     r0,[r1,#0]
;;;170    			if(Key_control < 4)
00001c  4810              LDR      r0,|L7.96|
00001e  7800              LDRB     r0,[r0,#0]  ; Key_control
000020  2804              CMP      r0,#4
000022  da05              BGE      |L7.48|
;;;171    			{
;;;172    				Key_control += 1;
000024  480e              LDR      r0,|L7.96|
000026  7800              LDRB     r0,[r0,#0]  ; Key_control
000028  1c40              ADDS     r0,r0,#1
00002a  490d              LDR      r1,|L7.96|
00002c  7008              STRB     r0,[r1,#0]
00002e  e002              B        |L7.54|
                  |L7.48|
;;;173    			}
;;;174    			else
;;;175    			{
;;;176    				Key_control = 1;
000030  2001              MOVS     r0,#1
000032  490b              LDR      r1,|L7.96|
000034  7008              STRB     r0,[r1,#0]
                  |L7.54|
;;;177    			}
;;;178    		break;
000036  e00b              B        |L7.80|
                  |L7.56|
;;;179    
;;;180    		case 1:
;;;181    		break;
000038  e00a              B        |L7.80|
                  |L7.58|
;;;182    
;;;183    		case 2:
;;;184    			key_state = ENABLE;
00003a  2001              MOVS     r0,#1
00003c  4906              LDR      r1,|L7.88|
00003e  7008              STRB     r0,[r1,#0]
;;;185    			key_state_confirm = 0;
000040  2000              MOVS     r0,#0
000042  4906              LDR      r1,|L7.92|
000044  7008              STRB     r0,[r1,#0]
;;;186    			Key_control = 2;
000046  2002              MOVS     r0,#2
000048  4905              LDR      r1,|L7.96|
00004a  7008              STRB     r0,[r1,#0]
;;;187    		break;
00004c  e000              B        |L7.80|
                  |L7.78|
;;;188    
;;;189    		default:
;;;190    		break;
00004e  bf00              NOP      
                  |L7.80|
000050  bf00              NOP                            ;178
;;;191    	}
;;;192    }
000052  4770              BX       lr
;;;193    
                          ENDP

                  |L7.84|
                          DCD      Interface_Key
                  |L7.88|
                          DCD      key_state
                  |L7.92|
                          DCD      key_state_confirm
                  |L7.96|
                          DCD      Key_control

                          AREA ||i.SystemManage_CheckPowerOff||, CODE, READONLY, ALIGN=2

                  SystemManage_CheckPowerOff PROC
;;;232    /******************************************************************************/
;;;233    void SystemManage_CheckPowerOff(void)
000000  b510              PUSH     {r4,lr}
;;;234    {
;;;235    	GPIO_ResetBits(GPIOB, GPIO_Pin_3);
000002  2108              MOVS     r1,#8
000004  4803              LDR      r0,|L8.20|
000006  f7fffffe          BL       GPIO_ResetBits
;;;236    	GPIO_ResetBits(GPIOD, GPIO_Pin_2);
00000a  2104              MOVS     r1,#4
00000c  4802              LDR      r0,|L8.24|
00000e  f7fffffe          BL       GPIO_ResetBits
;;;237    }
000012  bd10              POP      {r4,pc}
                          ENDP

                  |L8.20|
                          DCD      0x40010c00
                  |L8.24|
                          DCD      0x40011400

                          AREA ||.data||, DATA, ALIGN=0

                  key_open
000000  01                DCB      0x01
                  key_state
000001  01                DCB      0x01
                  Key_control
000002  01                DCB      0x01
                  Interface_Key
000003  00                DCB      0x00
                  key_state_confirm
000004  00                DCB      0x00
