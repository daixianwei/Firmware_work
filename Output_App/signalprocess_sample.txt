; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\Output_App\signalprocess_sample.o --asm_dir=..\Output_App\ --list_dir=..\Output_App\ --depend=..\Output_App\signalprocess_sample.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=870 -I.\System\CM3 -I.\System\FWlib\inc -I.\System\Startup -I.\ISR -I.\Main -I.\Management\DisplayDriver -I.\Management\HumanInput -I.\Management\Interface -I.\Management\RotationMotor -I.\Management\ScanMotor -I.\Management\Common_CRC -I.\Management\QRCode -I.\Management\SystemManage_RTC -I.\Management\SignalProcess_Sample -I.\USB -I.\USB\comm -I.\USB\lib -I.\USB\src -I.\USB\USB_Communication -ID:\Keil4.0\ARM\RV31\Inc -ID:\Keil4.0\ARM\CMSIS\Include -ID:\Keil4.0\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DUSE_STM3210E_EVAL -W --omf_browse=..\Output_App\signalprocess_sample.crf Management\SignalProcess_Sample\SignalProcess_Sample.c]
                          THUMB

                          AREA ||i.SignalProcess_Collecting_Data||, CODE, READONLY, ALIGN=1

                  SignalProcess_Collecting_Data PROC
;;;323    /******************************************************************************/
;;;324    vu16 SignalProcess_Collecting_Data(void)
000000  b510              PUSH     {r4,lr}
;;;325    {
;;;326    	vu16 sample_result;
;;;327    
;;;328    #if TIME_MEASUREMENT_ENABLED
;;;329    	Alarm_Time_Pin_High(); /* 50 times time consumption: 0.16ms */
;;;330    #endif
;;;331    
;;;332    	sample_result =
000002  2132              MOVS     r1,#0x32
000004  200a              MOVS     r0,#0xa
000006  f7fffffe          BL       SignalSample_Sample_Sampling
00000a  4604              MOV      r4,r0
;;;333    			SignalSample_Sample_Sampling(ADC_CH_VANALOG, VANALOG_SAMPLE_NUM);
;;;334    
;;;335    #if TIME_MEASUREMENT_ENABLED
;;;336    	Alarm_Time_Pin_Low();
;;;337    #endif
;;;338    	return sample_result;
00000c  4620              MOV      r0,r4
;;;339    }
00000e  bd10              POP      {r4,pc}
;;;340    
                          ENDP


                          AREA ||i.SignalSample_Clear_Buffer||, CODE, READONLY, ALIGN=2

                  SignalSample_Clear_Buffer PROC
;;;230    /******************************************************************************/
;;;231    void SignalSample_Clear_Buffer(void)
000000  2000              MOVS     r0,#0
;;;232    {
;;;233    	uint16 count = 0;
;;;234    
;;;235    	for (count = 0; count < SIGNALSAMPLE_MAX_COUNT; count++)
000002  bf00              NOP      
000004  e005              B        |L2.18|
                  |L2.6|
;;;236    	{
;;;237    		SignalProcess_sampleBuffer[count] = 0;
000006  2100              MOVS     r1,#0
000008  4a03              LDR      r2,|L2.24|
00000a  f8221010          STRH     r1,[r2,r0,LSL #1]
00000e  1c41              ADDS     r1,r0,#1              ;235
000010  b288              UXTH     r0,r1                 ;235
                  |L2.18|
000012  280a              CMP      r0,#0xa               ;235
000014  dbf7              BLT      |L2.6|
;;;238    	}
;;;239    }
000016  4770              BX       lr
;;;240    
                          ENDP

                  |L2.24|
                          DCD      SignalProcess_sampleBuffer

                          AREA ||i.SignalSample_GetVbat||, CODE, READONLY, ALIGN=2

                  SignalSample_GetVbat PROC
;;;351    /******************************************************************************/
;;;352    uint8 SignalSample_GetVbat(void)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;353    {
000004  b085              SUB      sp,sp,#0x14
;;;354    /*
;;;355    y = kx + b = 0.00203x - 0.0131
;;;356    
;;;357    Battery voltage, AD converted value
;;;358    4.2, 2080,
;;;359    4.0, 1980,
;;;360    3.8, 1880,
;;;361    3.6, 1780,
;;;362    3.4, 1680,
;;;363    3.3, 1640, Inaccurate when below 3.3V
;;;364    3.2, 1610,
;;;365    3.0, 1622
;;;366    */
;;;367    
;;;368    	/* voltage = coefA*sample + coefB */
;;;369    	float batLinCoefA = 0.00203;
000006  4826              LDR      r0,|L3.160|
000008  9004              STR      r0,[sp,#0x10]
;;;370    	float batLinCoefB = -0.0131;
00000a  4826              LDR      r0,|L3.164|
00000c  9003              STR      r0,[sp,#0xc]
;;;371    
;;;372    	uint16 batteryHalfCali = 0;
00000e  2000              MOVS     r0,#0
000010  9002              STR      r0,[sp,#8]
;;;373    	float batteryRealCali = 0;
000012  9001              STR      r0,[sp,#4]
;;;374    	uint8 percentage = 0;
000014  9000              STR      r0,[sp,#0]
;;;375    
;;;376    	/* Sample */
;;;377    	batteryHalfCali = SignalSample_Sample_Vbat();
000016  f7fffffe          BL       SignalSample_Sample_Vbat
00001a  9002              STR      r0,[sp,#8]
;;;378    
;;;379    	/* Calibration */
;;;380    	batteryRealCali = batLinCoefA * batteryHalfCali + batLinCoefB;
00001c  9802              LDR      r0,[sp,#8]
00001e  f7fffffe          BL       __aeabi_ui2f
000022  4605              MOV      r5,r0
000024  9904              LDR      r1,[sp,#0x10]
000026  f7fffffe          BL       __aeabi_fmul
00002a  4604              MOV      r4,r0
00002c  9903              LDR      r1,[sp,#0xc]
00002e  f7fffffe          BL       __aeabi_fadd
000032  9001              STR      r0,[sp,#4]
;;;381    
;;;382    	if (batteryRealCali >= BATTERY_MAX)
000034  9801              LDR      r0,[sp,#4]
000036  f7fffffe          BL       __aeabi_f2d
00003a  4604              MOV      r4,r0
00003c  4a1a              LDR      r2,|L3.168|
00003e  4b1b              LDR      r3,|L3.172|
000040  f7fffffe          BL       __aeabi_cdrcmple
000044  d802              BHI      |L3.76|
;;;383    	{
;;;384    		percentage = 100;
000046  2064              MOVS     r0,#0x64
000048  9000              STR      r0,[sp,#0]
00004a  e025              B        |L3.152|
                  |L3.76|
;;;385    	}
;;;386    	else if (batteryRealCali <= BATTERY_MIN)
00004c  9801              LDR      r0,[sp,#4]
00004e  f7fffffe          BL       __aeabi_f2d
000052  4604              MOV      r4,r0
000054  f04f3266          MOV      r2,#0x66666666
000058  4b15              LDR      r3,|L3.176|
00005a  f7fffffe          BL       __aeabi_cdcmple
00005e  d802              BHI      |L3.102|
;;;387    	{
;;;388    		percentage = 0;
000060  2000              MOVS     r0,#0
000062  9000              STR      r0,[sp,#0]
000064  e018              B        |L3.152|
                  |L3.102|
;;;389    	}
;;;390    	else
;;;391    	{
;;;392    		percentage = 100 * (batteryRealCali - BATTERY_MIN)/(BATTERY_MAX - BATTERY_MIN);
000066  9801              LDR      r0,[sp,#4]
000068  f7fffffe          BL       __aeabi_f2d
00006c  4604              MOV      r4,r0
00006e  f04f3266          MOV      r2,#0x66666666
000072  4b0f              LDR      r3,|L3.176|
000074  f7fffffe          BL       __aeabi_dsub
000078  4680              MOV      r8,r0
00007a  2200              MOVS     r2,#0
00007c  4b0d              LDR      r3,|L3.180|
00007e  f7fffffe          BL       __aeabi_dmul
000082  4606              MOV      r6,r0
000084  4a08              LDR      r2,|L3.168|
000086  1cd2              ADDS     r2,r2,#3
000088  4b0b              LDR      r3,|L3.184|
00008a  f7fffffe          BL       __aeabi_ddiv
00008e  4682              MOV      r10,r0
000090  f7fffffe          BL       __aeabi_d2uiz
000094  b2c0              UXTB     r0,r0
000096  9000              STR      r0,[sp,#0]
                  |L3.152|
;;;393    	}
;;;394    
;;;395    #if BATTERY_DEBUG_ENABLED
;;;396    	/* Output battery voltage: (X.XXX * 1000) mV */
;;;397    	SignalSample_OutputUint16_4C1S((uint16)(batteryRealCali * 1000));
;;;398    #endif
;;;399    
;;;400    	return percentage;
000098  9800              LDR      r0,[sp,#0]
;;;401    }
00009a  b005              ADD      sp,sp,#0x14
00009c  e8bd8ff0          POP      {r4-r11,pc}
;;;402    
                          ENDP

                  |L3.160|
                          DCD      0x3b0509c0
                  |L3.164|
                          DCD      0xbc56a162
                  |L3.168|
                          DCD      0xcccccccd
                  |L3.172|
                          DCD      0x4010cccc
                  |L3.176|
                          DCD      0x400a6666
                  |L3.180|
                          DCD      0x40590000
                  |L3.184|
                          DCD      0x3feccccc

                          AREA ||i.SignalSample_OutputSamples||, CODE, READONLY, ALIGN=1

                  SignalSample_OutputSamples PROC
;;;444    /******************************************************************************/
;;;445    void SignalSample_OutputSamples(uint16 sampleCount,uint16 *Sample_Data)
000000  4770              BX       lr
;;;446    {
;;;447    #if HOSTCOMM_ENABLED
;;;448    	unsigned short count = 0;
;;;449    	uint16 totalLength = sampleCount + 1;
;;;450    
;;;451    	if (!SignalProcess_output)
;;;452    		return;
;;;453    
;;;454    	/* Debugging: Output samples
;;;455    	 * Format: data length, data[0], data[1], ..., data[data length - 1] */
;;;456    
;;;457    	SignalProcess_sampleBuffer_BK[0] = sampleCount;
;;;458    	memcpy(&SignalProcess_sampleBuffer_BK[1], Sample_Data, sampleCount << 1);
;;;459    
;;;460    	for (count = 0; count < totalLength; count++)
;;;461    	{
;;;462    		SignalSample_OutputUint16_Each(SignalProcess_sampleBuffer_BK[count],
;;;463    				&SignalProcess_outputBuffer[5 * count]);
;;;464    	}
;;;465    
;;;466    	HostComm_SendThrUSB(5 * count, &SignalProcess_outputBuffer[0]);
;;;467    #endif
;;;468    }
;;;469    
                          ENDP


                          AREA ||i.SignalSample_OutputUint16_4C1S||, CODE, READONLY, ALIGN=1

                  SignalSample_OutputUint16_4C1S PROC
;;;403    /******************************************************************************/
;;;404    void SignalSample_OutputUint16_4C1S(uint16 value)
000000  4770              BX       lr
;;;405    {
;;;406    // 	uint8 outputData[5] = {0};
;;;407    // 	uint16 tmp, data;
;;;408    
;;;409    // 	/* 4 chars and 1 space */
;;;410    // 	data = value;
;;;411    // 	outputData[0] = data/1000 + 0x30;
;;;412    // 	tmp = data%1000;
;;;413    // 	outputData[1] = tmp/100 + 0x30;
;;;414    // 	tmp = data%100;
;;;415    // 	outputData[2] = tmp/10 + 0x30;
;;;416    // 	tmp = data%10;
;;;417    // 	outputData[3] = tmp + 0x30;
;;;418    //	outputData[4] = '\0';
;;;419    
;;;420    //	HostComm_Send(HOSTCOMM_USART, outputData);
;;;421    //	HostComm_Send(HOSTCOMM_USART, " ");
;;;422    }
;;;423    
                          ENDP


                          AREA ||i.SignalSample_OutputUint16_Each||, CODE, READONLY, ALIGN=1

                  SignalSample_OutputUint16_Each PROC
;;;424    /******************************************************************************/
;;;425    void SignalSample_OutputUint16_Each(uint16 value, uint8 *targetPtr)
000000  b53c              PUSH     {r2-r5,lr}
;;;426    {
000002  460b              MOV      r3,r1
;;;427    	uint8 outputData[5] = {0};
000004  2400              MOVS     r4,#0
000006  9400              STR      r4,[sp,#0]
000008  9401              STR      r4,[sp,#4]
;;;428    	uint16 tmp, data;
;;;429    
;;;430    	/* 4 chars and 1 space */
;;;431    	data = value;
00000a  4601              MOV      r1,r0
;;;432    	outputData[0] = data/1000 + 0x30;
00000c  f44f747a          MOV      r4,#0x3e8
000010  fb91f4f4          SDIV     r4,r1,r4
000014  3430              ADDS     r4,r4,#0x30
000016  b2e4              UXTB     r4,r4
000018  f88d4000          STRB     r4,[sp,#0]
;;;433    	tmp = data%1000;
00001c  f44f747a          MOV      r4,#0x3e8
000020  fb91f5f4          SDIV     r5,r1,r4
000024  fb041415          MLS      r4,r4,r5,r1
000028  b2a2              UXTH     r2,r4
;;;434    	outputData[1] = tmp/100 + 0x30;
00002a  2464              MOVS     r4,#0x64
00002c  fb92f4f4          SDIV     r4,r2,r4
000030  3430              ADDS     r4,r4,#0x30
000032  b2e4              UXTB     r4,r4
000034  f88d4001          STRB     r4,[sp,#1]
;;;435    	tmp = data%100;
000038  2464              MOVS     r4,#0x64
00003a  fb91f5f4          SDIV     r5,r1,r4
00003e  fb041415          MLS      r4,r4,r5,r1
000042  b2a2              UXTH     r2,r4
;;;436    	outputData[2] = tmp/10 + 0x30;
000044  240a              MOVS     r4,#0xa
000046  fb92f4f4          SDIV     r4,r2,r4
00004a  3430              ADDS     r4,r4,#0x30
00004c  b2e4              UXTB     r4,r4
00004e  f88d4002          STRB     r4,[sp,#2]
;;;437    	tmp = data%10;
000052  240a              MOVS     r4,#0xa
000054  fb91f5f4          SDIV     r5,r1,r4
000058  fb041415          MLS      r4,r4,r5,r1
00005c  b2a2              UXTH     r2,r4
;;;438    	outputData[3] = tmp + 0x30;
00005e  f1020430          ADD      r4,r2,#0x30
000062  b2e4              UXTB     r4,r4
000064  f88d4003          STRB     r4,[sp,#3]
;;;439    	outputData[4] = ' ';
000068  2420              MOVS     r4,#0x20
00006a  f88d4004          STRB     r4,[sp,#4]
;;;440    
;;;441    	memcpy(targetPtr, outputData, 4);
00006e  9c00              LDR      r4,[sp,#0]
000070  601c              STR      r4,[r3,#0]
;;;442    }
000072  bd3c              POP      {r2-r5,pc}
;;;443    
                          ENDP


                          AREA ||i.SignalSample_SampleStrip||, CODE, READONLY, ALIGN=2

                  SignalSample_SampleStrip PROC
;;;526    /******************************************************************************/
;;;527    void SignalSample_SampleStrip(uint8 prog)
000000  b570              PUSH     {r4-r6,lr}
;;;528    {
000002  4605              MOV      r5,r0
;;;529    	uint16 moveSteps = MOTOR_SAMPLE_STEPS - 1;
000004  24d8              MOVS     r4,#0xd8
;;;530    
;;;531    	/* 1st stage: prepare to sample */
;;;532    	/* 1.1 Enable 5V power supply */
;;;533    	SystemManage_5V_Enabled();
000006  f7fffffe          BL       SystemManage_5V_Enabled
;;;534    
;;;535    	/* 1.2 Goto base position, then goto detection position */
;;;536    //	ScanMotorDriver_Goto_BasePosition();
;;;537    
;;;538    	/* 1.3 Enter critical area */
;;;539    	SignalSample_Sample_EnterCriticalArea();
00000a  f7fffffe          BL       SignalSample_Sample_EnterCriticalArea
;;;540    
;;;541    	/* 2nd stage: start timer, move motor per interval then sample */
;;;542    	/* 2.1 Initialize timer */
;;;543    	SignalSample_Sample_Timer_Init();
00000e  f7fffffe          BL       SignalSample_Sample_Timer_Init
;;;544    
;;;545    	if(CAN_POSSEN_INT_STATE())
000012  2102              MOVS     r1,#2
000014  4821              LDR      r0,|L7.156|
000016  f7fffffe          BL       GPIO_ReadInputDataBit
00001a  b1e0              CBZ      r0,|L7.86|
;;;546    	{
;;;547    		/* 2.2 Move motor per interval, then sample */
;;;548    		for (;;)
00001c  bf00              NOP      
                  |L7.30|
;;;549    			{
;;;550    				if (SignalSample_moveThenSample)
00001e  4820              LDR      r0,|L7.160|
000020  7800              LDRB     r0,[r0,#0]  ; SignalSample_moveThenSample
000022  2800              CMP      r0,#0
000024  d0fb              BEQ      |L7.30|
;;;551    				{
;;;552    					/* Timer notifies */
;;;553    					SignalSample_moveThenSample = 0;
000026  2000              MOVS     r0,#0
000028  491d              LDR      r1,|L7.160|
00002a  7008              STRB     r0,[r1,#0]
;;;554    					/* Move one step */
;;;555    					ScanMotorDriver_Move(ScanMotorDriver_DIR_OUT,1);
00002c  2101              MOVS     r1,#1
00002e  f7fffffe          BL       ScanMotorDriver_Move
;;;556    					/* Sample one time */
;;;557    					SignalProcess_sampleBuffer[SignalSample_count++]
000032  f7fffffe          BL       SignalProcess_Collecting_Data
000036  491b              LDR      r1,|L7.164|
000038  880a              LDRH     r2,[r1,#0]  ; SignalSample_count
00003a  8809              LDRH     r1,[r1,#0]  ; SignalSample_count
00003c  1c49              ADDS     r1,r1,#1
00003e  4b19              LDR      r3,|L7.164|
000040  8019              STRH     r1,[r3,#0]
000042  4919              LDR      r1,|L7.168|
000044  f8210012          STRH     r0,[r1,r2,LSL #1]
;;;558    											   = SignalProcess_Collecting_Data();
;;;559    					/* Determine exit condition */
;;;560    					if (!(moveSteps--))
000048  0020              MOVS     r0,r4
00004a  f1a40101          SUB      r1,r4,#1
00004e  b28c              UXTH     r4,r1
000050  d1e5              BNE      |L7.30|
;;;561    						break;
000052  bf00              NOP      
000054  e00c              B        |L7.112|
                  |L7.86|
;;;562    				}
;;;563    			}
;;;564    	}
;;;565    	else
;;;566    	{
;;;567    		ScanMotorDriver_Goto_BasePosition();
000056  f7fffffe          BL       ScanMotorDriver_Goto_BasePosition
;;;568    		SignalProcess_sampleBuffer[SignalSample_count++]
00005a  f7fffffe          BL       SignalProcess_Collecting_Data
00005e  4911              LDR      r1,|L7.164|
000060  880a              LDRH     r2,[r1,#0]  ; SignalSample_count
000062  8809              LDRH     r1,[r1,#0]  ; SignalSample_count
000064  1c49              ADDS     r1,r1,#1
000066  4b0f              LDR      r3,|L7.164|
000068  8019              STRH     r1,[r3,#0]
00006a  490f              LDR      r1,|L7.168|
00006c  f8210012          STRH     r0,[r1,r2,LSL #1]
                  |L7.112|
;;;569    											= SignalProcess_Collecting_Data();
;;;570    	}
;;;571    
;;;572    	/* 3rd stage: Post process */
;;;573    	/* 3.1 Disable timer */
;;;574    	SignalSample_Sample_Timer_Disabled();
000070  f7fffffe          BL       SignalSample_Sample_Timer_Disabled
;;;575    
;;;576    	/* 3.2 Exit critical area */
;;;577    	SignalSample_Sample_ExitCriticalArea();
000074  f7fffffe          BL       SignalSample_Sample_ExitCriticalArea
;;;578    
;;;579    	/* 3.3 Disable 5V power supply */
;;;580    	SystemManage_5V_Disabled();
000078  f7fffffe          BL       SystemManage_5V_Disabled
;;;581    
;;;582    	/* Output samples */
;;;583    	SignalSample_OutputSamples(SignalSample_count,
00007c  490a              LDR      r1,|L7.168|
00007e  4809              LDR      r0,|L7.164|
000080  8800              LDRH     r0,[r0,#0]  ; SignalSample_count
000082  f7fffffe          BL       SignalSample_OutputSamples
;;;584    			SignalProcess_sampleBuffer);
;;;585    
;;;586    	DisplayDriver_Text16(12,25,Black,(uint8 *)SignalProcess_sampleBuffer);
000086  4b08              LDR      r3,|L7.168|
000088  2200              MOVS     r2,#0
00008a  2119              MOVS     r1,#0x19
00008c  200c              MOVS     r0,#0xc
00008e  f7fffffe          BL       DisplayDriver_Text16
;;;587    	Delay_ms(500);
000092  f44f70fa          MOV      r0,#0x1f4
000096  f7fffffe          BL       Delay_ms
;;;588    }
00009a  bd70              POP      {r4-r6,pc}
                          ENDP

                  |L7.156|
                          DCD      0x40010800
                  |L7.160|
                          DCD      SignalSample_moveThenSample
                  |L7.164|
                          DCD      SignalSample_count
                  |L7.168|
                          DCD      SignalProcess_sampleBuffer

                          AREA ||i.SignalSample_Sample_AD84XX_Init||, CODE, READONLY, ALIGN=2

                  SignalSample_Sample_AD84XX_Init PROC
;;;241    /******************************************************************************/
;;;242    void SignalSample_Sample_AD84XX_Init(void)
000000  b500              PUSH     {lr}
;;;243    {
000002  b087              SUB      sp,sp,#0x1c
;;;244    	SPI_InitTypeDef  SPI_InitStructure;
;;;245    	GPIO_InitTypeDef GPIO_InitStructure;
;;;246    
;;;247    	/* CS */
;;;248    	GPIO_InitStructure.GPIO_Pin = AD84XX_CS_PIN;
000004  2010              MOVS     r0,#0x10
000006  f8ad0004          STRH     r0,[sp,#4]
;;;249    	GPIO_InitStructure.GPIO_Speed =GPIO_Speed_50MHz;
00000a  2003              MOVS     r0,#3
00000c  f88d0006          STRB     r0,[sp,#6]
;;;250    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
000010  2010              MOVS     r0,#0x10
000012  f88d0007          STRB     r0,[sp,#7]
;;;251    	GPIO_Init(AD84XX_CS_PORT, &GPIO_InitStructure);
000016  a901              ADD      r1,sp,#4
000018  481e              LDR      r0,|L8.148|
00001a  f7fffffe          BL       GPIO_Init
;;;252    
;;;253    	/* SPI1 */
;;;254    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1 ,ENABLE);
00001e  2101              MOVS     r1,#1
000020  0308              LSLS     r0,r1,#12
000022  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;255    	/* SCK, MISO, MOSI */
;;;256    	GPIO_InitStructure.GPIO_Pin = AD84XX_SPI_PIN;
000026  20a0              MOVS     r0,#0xa0
000028  f8ad0004          STRH     r0,[sp,#4]
;;;257    	GPIO_InitStructure.GPIO_Speed =GPIO_Speed_50MHz;
00002c  2003              MOVS     r0,#3
00002e  f88d0006          STRB     r0,[sp,#6]
;;;258    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
000032  2018              MOVS     r0,#0x18
000034  f88d0007          STRB     r0,[sp,#7]
;;;259    	GPIO_Init(AD84XX_SPI_PORT, &GPIO_InitStructure);
000038  a901              ADD      r1,sp,#4
00003a  4816              LDR      r0,|L8.148|
00003c  f7fffffe          BL       GPIO_Init
;;;260    
;;;261    	/* SPI1 */
;;;262    	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
000040  2000              MOVS     r0,#0
000042  f8ad0008          STRH     r0,[sp,#8]
;;;263    	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;
000046  f44f7082          MOV      r0,#0x104
00004a  f8ad000a          STRH     r0,[sp,#0xa]
;;;264    	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
00004e  2000              MOVS     r0,#0
000050  f8ad000c          STRH     r0,[sp,#0xc]
;;;265    	SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;
000054  2002              MOVS     r0,#2
000056  f8ad000e          STRH     r0,[sp,#0xe]
;;;266    	SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;
00005a  2001              MOVS     r0,#1
00005c  f8ad0010          STRH     r0,[sp,#0x10]
;;;267    	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
000060  0240              LSLS     r0,r0,#9
000062  f8ad0012          STRH     r0,[sp,#0x12]
;;;268    	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_8;
000066  2010              MOVS     r0,#0x10
000068  f8ad0014          STRH     r0,[sp,#0x14]
;;;269    	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
00006c  2000              MOVS     r0,#0
00006e  f8ad0016          STRH     r0,[sp,#0x16]
;;;270    	SPI_InitStructure.SPI_CRCPolynomial = 7;
000072  2007              MOVS     r0,#7
000074  f8ad0018          STRH     r0,[sp,#0x18]
;;;271    	SPI_Init(SPI1, &SPI_InitStructure);
000078  a902              ADD      r1,sp,#8
00007a  4807              LDR      r0,|L8.152|
00007c  f7fffffe          BL       SPI_Init
;;;272    
;;;273    	/* SPI1 */
;;;274    	SPI_Cmd(SPI1, ENABLE);
000080  2101              MOVS     r1,#1
000082  4805              LDR      r0,|L8.152|
000084  f7fffffe          BL       SPI_Cmd
;;;275    
;;;276    	/* Select */
;;;277    	SIGNALSAMPLE_AD84XX_CS_Disable();
000088  2110              MOVS     r1,#0x10
00008a  4802              LDR      r0,|L8.148|
00008c  f7fffffe          BL       GPIO_SetBits
;;;278    }
000090  b007              ADD      sp,sp,#0x1c
000092  bd00              POP      {pc}
;;;279    
                          ENDP

                  |L8.148|
                          DCD      0x40010800
                  |L8.152|
                          DCD      0x40013000

                          AREA ||i.SignalSample_Sample_AD84XX_SendByte||, CODE, READONLY, ALIGN=2

                  SignalSample_Sample_AD84XX_SendByte PROC
;;;280    /******************************************************************************/
;;;281    void SignalSample_Sample_AD84XX_SendByte(u8 byte)
000000  b510              PUSH     {r4,lr}
;;;282    {
000002  4604              MOV      r4,r0
;;;283    	/* Loop while DR register in not emplty */
;;;284    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET);
000004  bf00              NOP      
                  |L9.6|
000006  2102              MOVS     r1,#2
000008  4804              LDR      r0,|L9.28|
00000a  f7fffffe          BL       SPI_I2S_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L9.6|
;;;285    
;;;286    	/* Send byte through the SPI2 peripheral */
;;;287    	SPI_I2S_SendData(SPI1, byte);
000012  4621              MOV      r1,r4
000014  4801              LDR      r0,|L9.28|
000016  f7fffffe          BL       SPI_I2S_SendData
;;;288    }
00001a  bd10              POP      {r4,pc}
;;;289    
                          ENDP

                  |L9.28|
                          DCD      0x40013000

                          AREA ||i.SignalSample_Sample_ADC_Init||, CODE, READONLY, ALIGN=2

                  SignalSample_Sample_ADC_Init PROC
;;;105    /******************************************************************************/
;;;106    void SignalSample_Sample_ADC_Init(void)
000000  b500              PUSH     {lr}
;;;107    {
000002  b087              SUB      sp,sp,#0x1c
;;;108    	GPIO_InitTypeDef GPIO_InitStructure;
;;;109    	ADC_InitTypeDef ADC_InitStructure;
;;;110    
;;;111        /* Enable ADC1 and GPIOC clock */
;;;112    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC | RCC_APB2Periph_ADC1, ENABLE);
000004  2101              MOVS     r1,#1
000006  f44f7004          MOV      r0,#0x210
00000a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;113    
;;;114    	/* Configure PC0/1/2/3/4/5 as analog input */
;;;115    	GPIO_InitStructure.GPIO_Pin = SIGNAL_INPUT_PIN;
00000e  2003              MOVS     r0,#3
000010  f8ad0018          STRH     r0,[sp,#0x18]
;;;116    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
000014  2000              MOVS     r0,#0
000016  f88d001b          STRB     r0,[sp,#0x1b]
;;;117    	GPIO_Init(SIGNAL_INPUT_PORT, &GPIO_InitStructure);
00001a  a906              ADD      r1,sp,#0x18
00001c  481b              LDR      r0,|L10.140|
00001e  f7fffffe          BL       GPIO_Init
;;;118    
;;;119    	/* Configure ADC */
;;;120    	ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
000022  2000              MOVS     r0,#0
000024  9001              STR      r0,[sp,#4]
;;;121    	ADC_InitStructure.ADC_ScanConvMode = ENABLE;
000026  2001              MOVS     r0,#1
000028  f88d0008          STRB     r0,[sp,#8]
;;;122    	ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
00002c  f88d0009          STRB     r0,[sp,#9]
;;;123    	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
000030  f44f2060          MOV      r0,#0xe0000
000034  9003              STR      r0,[sp,#0xc]
;;;124    	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
000036  2000              MOVS     r0,#0
000038  9004              STR      r0,[sp,#0x10]
;;;125    	ADC_InitStructure.ADC_NbrOfChannel = 1;//SIGNALSAMPLE_CHANNEL_NUM;
00003a  2001              MOVS     r0,#1
00003c  f88d0014          STRB     r0,[sp,#0x14]
;;;126    	ADC_Init(ADC1, &ADC_InitStructure);
000040  a901              ADD      r1,sp,#4
000042  4813              LDR      r0,|L10.144|
000044  f7fffffe          BL       ADC_Init
;;;127    
;;;128    	/* ADC1 regular configuration */
;;;129    	ADC_RegularChannelConfig(ADC1, ADC_CH_VANALOG, 1, ADC_SampleTime_55Cycles5);
000048  2305              MOVS     r3,#5
00004a  2201              MOVS     r2,#1
00004c  210a              MOVS     r1,#0xa
00004e  4810              LDR      r0,|L10.144|
000050  f7fffffe          BL       ADC_RegularChannelConfig
;;;130    
;;;131    	/* Enable ADC1 */
;;;132    	ADC_Cmd(ADC1, ENABLE);
000054  2101              MOVS     r1,#1
000056  480e              LDR      r0,|L10.144|
000058  f7fffffe          BL       ADC_Cmd
;;;133    
;;;134    	/* Enable ADC1 reset calibaration register */
;;;135    	ADC_ResetCalibration(ADC1);
00005c  480c              LDR      r0,|L10.144|
00005e  f7fffffe          BL       ADC_ResetCalibration
;;;136    
;;;137    	/* Check the end of ADC1 reset calibration register */
;;;138    	while(ADC_GetResetCalibrationStatus(ADC1));
000062  bf00              NOP      
                  |L10.100|
000064  480a              LDR      r0,|L10.144|
000066  f7fffffe          BL       ADC_GetResetCalibrationStatus
00006a  2800              CMP      r0,#0
00006c  d1fa              BNE      |L10.100|
;;;139    
;;;140    	/* Start ADC1 calibaration */
;;;141    	ADC_StartCalibration(ADC1);
00006e  4808              LDR      r0,|L10.144|
000070  f7fffffe          BL       ADC_StartCalibration
;;;142    	/* Check the end of ADC1 calibration */
;;;143    	while(ADC_GetCalibrationStatus(ADC1));
000074  bf00              NOP      
                  |L10.118|
000076  4806              LDR      r0,|L10.144|
000078  f7fffffe          BL       ADC_GetCalibrationStatus
00007c  2800              CMP      r0,#0
00007e  d1fa              BNE      |L10.118|
;;;144    
;;;145    	/* Disable ADC1 Software Conversion */
;;;146    	ADC_SoftwareStartConvCmd(ADC1, DISABLE);
000080  2100              MOVS     r1,#0
000082  4803              LDR      r0,|L10.144|
000084  f7fffffe          BL       ADC_SoftwareStartConvCmd
;;;147    }
000088  b007              ADD      sp,sp,#0x1c
00008a  bd00              POP      {pc}
;;;148    
                          ENDP

                  |L10.140|
                          DCD      0x40011000
                  |L10.144|
                          DCD      0x40012400

                          AREA ||i.SignalSample_Sample_EnterCriticalArea||, CODE, READONLY, ALIGN=2

                  SignalSample_Sample_EnterCriticalArea PROC
;;;508    /******************************************************************************/
;;;509    void SignalSample_Sample_EnterCriticalArea(void)
000000  b510              PUSH     {r4,lr}
;;;510    {
;;;511    	/* Turn on current source */
;;;512    	SignalSample_Sample_Set_LED(ABNORMAL_ON);
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       SignalSample_Sample_Set_LED
;;;513    
;;;514    	/* Initialize variables */
;;;515    	SignalSample_count = 0;
000008  2000              MOVS     r0,#0
00000a  4902              LDR      r1,|L11.20|
00000c  8008              STRH     r0,[r1,#0]
;;;516    	SignalSample_moveThenSample = 0;
00000e  4902              LDR      r1,|L11.24|
000010  7008              STRB     r0,[r1,#0]
;;;517    }
000012  bd10              POP      {r4,pc}
;;;518    
                          ENDP

                  |L11.20|
                          DCD      SignalSample_count
                  |L11.24|
                          DCD      SignalSample_moveThenSample

                          AREA ||i.SignalSample_Sample_ExitCriticalArea||, CODE, READONLY, ALIGN=1

                  SignalSample_Sample_ExitCriticalArea PROC
;;;519    /******************************************************************************/
;;;520    void SignalSample_Sample_ExitCriticalArea(void)
000000  b510              PUSH     {r4,lr}
;;;521    {
;;;522    	/* Turn off current source */
;;;523    	SignalSample_Sample_Set_LED(ABNORMAL_OFF);
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       SignalSample_Sample_Set_LED
;;;524    }
000008  bd10              POP      {r4,pc}
;;;525    
                          ENDP


                          AREA ||i.SignalSample_Sample_Init||, CODE, READONLY, ALIGN=1

                  SignalSample_Sample_Init PROC
;;;45     /******************************************************************************/
;;;46     void SignalSample_Sample_Init(void)
000000  b510              PUSH     {r4,lr}
;;;47     {
;;;48     	/* Strip position sensor */
;;;49     	SignalSample_Sample_Strip_Sensor_Init();
000002  f7fffffe          BL       SignalSample_Sample_Strip_Sensor_Init
;;;50     
;;;51     	/* Initialize signal LED */
;;;52     	SignalSample_Sample_LED_Init();
000006  f7fffffe          BL       SignalSample_Sample_LED_Init
;;;53     
;;;54     	/* Initialize AD84XX */
;;;55     	SignalSample_Sample_AD84XX_Init();
00000a  f7fffffe          BL       SignalSample_Sample_AD84XX_Init
;;;56     
;;;57     	/* Set resistor */
;;;58     	SignalSample_Sample_SetResistor();
00000e  f7fffffe          BL       SignalSample_Sample_SetResistor
;;;59     
;;;60     	SignalSample_Sample_Timer_Init();
000012  f7fffffe          BL       SignalSample_Sample_Timer_Init
;;;61     
;;;62     #if RL_A3000
;;;63     	/* Initialize ADG1609 */
;;;64     	SignalSample_Sample_ADG1609_Init();
;;;65     #endif
;;;66     
;;;67     	/* Initialize ADC */
;;;68     	SignalSample_Sample_ADC_Init();
000016  f7fffffe          BL       SignalSample_Sample_ADC_Init
;;;69     
;;;70     	/* Battery check:
;;;71     	 * if battery is too low, shut down again */
;;;72     // 	if (SignalSample_GetVbat() == 0)
;;;73     // 	{
;;;74     // //		SystemManage_EnterStandby();
;;;75     // 	}
;;;76     }
00001a  bd10              POP      {r4,pc}
;;;77     
                          ENDP


                          AREA ||i.SignalSample_Sample_IsStripInserted||, CODE, READONLY, ALIGN=2

                  SignalSample_Sample_IsStripInserted PROC
;;;313    /******************************************************************************/
;;;314    uint8 SignalSample_Sample_IsStripInserted(void)
000000  b510              PUSH     {r4,lr}
;;;315    {
;;;316    #if REAGENT_CARD_TRIGGER_LEVEL_REVERSED
;;;317    	return STRIP_SENSOR_STATE();
;;;318    #else
;;;319    	return !STRIP_SENSOR_STATE();
000002  2180              MOVS     r1,#0x80
000004  4803              LDR      r0,|L14.20|
000006  f7fffffe          BL       GPIO_ReadInputDataBit
00000a  b908              CBNZ     r0,|L14.16|
00000c  2001              MOVS     r0,#1
                  |L14.14|
;;;320    #endif
;;;321    }
00000e  bd10              POP      {r4,pc}
                  |L14.16|
000010  2000              MOVS     r0,#0                 ;319
000012  e7fc              B        |L14.14|
;;;322    
                          ENDP

                  |L14.20|
                          DCD      0x40011000

                          AREA ||i.SignalSample_Sample_LED_Init||, CODE, READONLY, ALIGN=2

                  SignalSample_Sample_LED_Init PROC
;;;203    /******************************************************************************/
;;;204    void SignalSample_Sample_LED_Init(void)
000000  b508              PUSH     {r3,lr}
;;;205    {
;;;206    	GPIO_InitTypeDef GPIO_InitStructure;
;;;207    
;;;208    	GPIO_InitStructure.GPIO_Pin = SIGNAL_LED_PIN;
000002  2008              MOVS     r0,#8
000004  f8ad0000          STRH     r0,[sp,#0]
;;;209    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
000008  2010              MOVS     r0,#0x10
00000a  f88d0003          STRB     r0,[sp,#3]
;;;210    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00000e  2003              MOVS     r0,#3
000010  f88d0002          STRB     r0,[sp,#2]
;;;211    	GPIO_Init(SIGNAL_LED_PORT, &GPIO_InitStructure);
000014  4669              MOV      r1,sp
000016  4803              LDR      r0,|L15.36|
000018  f7fffffe          BL       GPIO_Init
;;;212    
;;;213    	/* Turn off LED */
;;;214    	SignalSample_Sample_Set_LED(ABNORMAL_OFF);
00001c  2001              MOVS     r0,#1
00001e  f7fffffe          BL       SignalSample_Sample_Set_LED
;;;215    }
000022  bd08              POP      {r3,pc}
;;;216    
                          ENDP

                  |L15.36|
                          DCD      0x40011800

                          AREA ||i.SignalSample_Sample_Sampling||, CODE, READONLY, ALIGN=2

                  SignalSample_Sample_Sampling PROC
;;;163    /******************************************************************************/
;;;164    vu16 SignalSample_Sample_Sampling(uint8 ch, uint16 sampleNum)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;165    {
000004  4681              MOV      r9,r0
000006  460c              MOV      r4,r1
;;;166    #define ALGORITHM_AVERAGE 1
;;;167    #define ALGORITHM_MID_AVERAGE 0
;;;168    	vu32 sampleDataSum = 0;
000008  2500              MOVS     r5,#0
;;;169    	vu16 sampleDataAvr = 0;
00000a  bf00              NOP      
;;;170    	vu16 result = 0;
00000c  bf00              NOP      
;;;171    	uint32 index;
;;;172    
;;;173    	/* Start ADC */
;;;174    	SignalSample_Sample_Start(ch);
00000e  4648              MOV      r0,r9
000010  f7fffffe          BL       SignalSample_Sample_Start
;;;175    
;;;176    #if ALGORITHM_AVERAGE
;;;177    	for (index = 0; index < sampleNum; index++)
000014  46a8              MOV      r8,r5
000016  e010              B        |L16.58|
                  |L16.24|
;;;178    	{
;;;179    		/* Start conversion */
;;;180    		ADC_SoftwareStartConvCmd(ADC1, ENABLE);
000018  2101              MOVS     r1,#1
00001a  480f              LDR      r0,|L16.88|
00001c  f7fffffe          BL       ADC_SoftwareStartConvCmd
;;;181    		/* Wait for completion */
;;;182    		while(!ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC));
000020  bf00              NOP      
                  |L16.34|
000022  2102              MOVS     r1,#2
000024  480c              LDR      r0,|L16.88|
000026  f7fffffe          BL       ADC_GetFlagStatus
00002a  2800              CMP      r0,#0
00002c  d0f9              BEQ      |L16.34|
;;;183    		/* Get sum */
;;;184    		sampleDataSum += ADC_GetConversionValue(ADC1);
00002e  480a              LDR      r0,|L16.88|
000030  f7fffffe          BL       ADC_GetConversionValue
000034  4405              ADD      r5,r5,r0
000036  f1080801          ADD      r8,r8,#1              ;177
                  |L16.58|
00003a  45a0              CMP      r8,r4                 ;177
00003c  d3ec              BCC      |L16.24|
;;;185    	}
;;;186    
;;;187    	/* Get average value */
;;;188    	sampleDataAvr = sampleDataSum / sampleNum;
00003e  fbb5f0f4          UDIV     r0,r5,r4
000042  b286              UXTH     r6,r0
;;;189    
;;;190    #elif ALGORITHM_MID_AVERAGE
;;;191    
;;;192    #endif
;;;193    
;;;194    	/* Convert to voltage (unit is mV) */
;;;195    	result = (sampleDataAvr * VREF_MV) >> ADC_BITS;
000044  f64010c4          MOV      r0,#0x9c4
000048  4370              MULS     r0,r6,r0
00004a  1307              ASRS     r7,r0,#12
;;;196    
;;;197    	/* Stop ADC */
;;;198    	SignalSample_Sample_Stop(ch);
00004c  4648              MOV      r0,r9
00004e  f7fffffe          BL       SignalSample_Sample_Stop
;;;199    
;;;200    	return result;
000052  4638              MOV      r0,r7
;;;201    }
000054  e8bd87f0          POP      {r4-r10,pc}
;;;202    
                          ENDP

                  |L16.88|
                          DCD      0x40012400

                          AREA ||i.SignalSample_Sample_SetResistor||, CODE, READONLY, ALIGN=2

                  SignalSample_Sample_SetResistor PROC
;;;78     /******************************************************************************/
;;;79     void SignalSample_Sample_SetResistor(void)
000000  b510              PUSH     {r4,lr}
;;;80     {
;;;81     	SignalSample_SetResistor(SIGNALSAMPLE_AD84XX_CH1,
000002  4803              LDR      r0,|L17.16|
000004  7801              LDRB     r1,[r0,#0]  ; SignalSample_resistorValue
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       SignalSample_SetResistor
;;;82     			SignalSample_resistorValue);
;;;83     }
00000c  bd10              POP      {r4,pc}
;;;84     
                          ENDP

00000e  0000              DCW      0x0000
                  |L17.16|
                          DCD      SignalSample_resistorValue

                          AREA ||i.SignalSample_Sample_Set_LED||, CODE, READONLY, ALIGN=2

                  SignalSample_Sample_Set_LED PROC
;;;217    /******************************************************************************/
;;;218    void SignalSample_Sample_Set_LED(u8 flag)
000000  b510              PUSH     {r4,lr}
;;;219    {
000002  4604              MOV      r4,r0
;;;220    	if(flag)
000004  b124              CBZ      r4,|L18.16|
;;;221    	{
;;;222    		GPIO_SetBits(SIGNAL_LED_PORT, SIGNAL_LED_PIN);
000006  2108              MOVS     r1,#8
000008  4804              LDR      r0,|L18.28|
00000a  f7fffffe          BL       GPIO_SetBits
00000e  e003              B        |L18.24|
                  |L18.16|
;;;223    	}
;;;224    	else
;;;225    	{
;;;226    		GPIO_ResetBits(SIGNAL_LED_PORT, SIGNAL_LED_PIN);
000010  2108              MOVS     r1,#8
000012  4802              LDR      r0,|L18.28|
000014  f7fffffe          BL       GPIO_ResetBits
                  |L18.24|
;;;227    	}
;;;228    }
000018  bd10              POP      {r4,pc}
;;;229    
                          ENDP

00001a  0000              DCW      0x0000
                  |L18.28|
                          DCD      0x40011800

                          AREA ||i.SignalSample_Sample_Start||, CODE, READONLY, ALIGN=2

                  SignalSample_Sample_Start PROC
;;;149    /******************************************************************************/
;;;150    void SignalSample_Sample_Start(uint8 ch)
000000  b510              PUSH     {r4,lr}
;;;151    {
000002  4604              MOV      r4,r0
;;;152    	/* Configure ADC channel per input */
;;;153    	ADC_RegularChannelConfig(ADC1, ch, 1, ADC_SampleTime_55Cycles5);
000004  2305              MOVS     r3,#5
000006  2201              MOVS     r2,#1
000008  4621              MOV      r1,r4
00000a  4802              LDR      r0,|L19.20|
00000c  f7fffffe          BL       ADC_RegularChannelConfig
;;;154    }
000010  bd10              POP      {r4,pc}
;;;155    
                          ENDP

000012  0000              DCW      0x0000
                  |L19.20|
                          DCD      0x40012400

                          AREA ||i.SignalSample_Sample_Stop||, CODE, READONLY, ALIGN=2

                  SignalSample_Sample_Stop PROC
;;;156    /******************************************************************************/
;;;157    void SignalSample_Sample_Stop(uint8 ch)
000000  b510              PUSH     {r4,lr}
;;;158    {
000002  4604              MOV      r4,r0
;;;159    	/* Disable ADC1 */
;;;160    	ADC_SoftwareStartConvCmd(ADC1, DISABLE);
000004  2100              MOVS     r1,#0
000006  4802              LDR      r0,|L20.16|
000008  f7fffffe          BL       ADC_SoftwareStartConvCmd
;;;161    }
00000c  bd10              POP      {r4,pc}
;;;162    
                          ENDP

00000e  0000              DCW      0x0000
                  |L20.16|
                          DCD      0x40012400

                          AREA ||i.SignalSample_Sample_Strip_Sensor_Init||, CODE, READONLY, ALIGN=2

                  SignalSample_Sample_Strip_Sensor_Init PROC
;;;85     /******************************************************************************/
;;;86     void SignalSample_Sample_Strip_Sensor_Init(void)
000000  b500              PUSH     {lr}
;;;87     {
000002  b087              SUB      sp,sp,#0x1c
;;;88     	Common_EXTI_Init(STRIP_SENSOR_PORT, STRIP_SENSOR_PIN,
000004  2006              MOVS     r0,#6
000006  2101              MOVS     r1,#1
000008  2217              MOVS     r2,#0x17
00000a  2300              MOVS     r3,#0
00000c  e9cd3202          STRD     r3,r2,[sp,#8]
000010  e9cd1004          STRD     r1,r0,[sp,#0x10]
000014  2010              MOVS     r0,#0x10
000016  2180              MOVS     r1,#0x80
000018  2307              MOVS     r3,#7
00001a  2202              MOVS     r2,#2
00001c  e9cd1000          STRD     r1,r0,[sp,#0]
000020  4802              LDR      r0,|L21.44|
000022  f7fffffe          BL       Common_EXTI_Init
;;;89     			GPIO_PortSourceGPIOC, GPIO_PinSource7, EXTI_Line7, EXTI_Trigger_Rising_Falling,
;;;90     			DISABLE, EXTI9_5_IRQn, 0X01, 0X06);
;;;91     }
000026  b007              ADD      sp,sp,#0x1c
000028  bd00              POP      {pc}
;;;92     
                          ENDP

00002a  0000              DCW      0x0000
                  |L21.44|
                          DCD      0x40011000

                          AREA ||i.SignalSample_Sample_Strip_Sensor_Int||, CODE, READONLY, ALIGN=1

                  SignalSample_Sample_Strip_Sensor_Int PROC
;;;93     /******************************************************************************/
;;;94     void SignalSample_Sample_Strip_Sensor_Int(FunctionalState state)
000000  b51c              PUSH     {r2-r4,lr}
;;;95     {
000002  4604              MOV      r4,r0
;;;96     	EXTI_InitTypeDef EXTI_InitStructure;
;;;97     
;;;98     	EXTI_InitStructure.EXTI_Line = EXTI_Line7;
000004  2080              MOVS     r0,#0x80
000006  9000              STR      r0,[sp,#0]
;;;99     	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
000008  2000              MOVS     r0,#0
00000a  f88d0004          STRB     r0,[sp,#4]
;;;100    	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising_Falling;
00000e  2010              MOVS     r0,#0x10
000010  f88d0005          STRB     r0,[sp,#5]
;;;101    	EXTI_InitStructure.EXTI_LineCmd = state;
000014  f88d4006          STRB     r4,[sp,#6]
;;;102    	EXTI_Init(&EXTI_InitStructure);
000018  4668              MOV      r0,sp
00001a  f7fffffe          BL       EXTI_Init
;;;103    }
00001e  bd1c              POP      {r2-r4,pc}
;;;104    
                          ENDP


                          AREA ||i.SignalSample_Sample_Timer_Disabled||, CODE, READONLY, ALIGN=2

                  SignalSample_Sample_Timer_Disabled PROC
;;;495    /******************************************************************************/
;;;496    void SignalSample_Sample_Timer_Disabled(void)
000000  b510              PUSH     {r4,lr}
;;;497    {
;;;498    	SignalSample_Sample_Timer_Int(DISABLE);
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       SignalSample_Sample_Timer_Int
;;;499    	TIM_Cmd(TIM3, DISABLE);
000008  2100              MOVS     r1,#0
00000a  4802              LDR      r0,|L23.20|
00000c  f7fffffe          BL       TIM_Cmd
;;;500    }
000010  bd10              POP      {r4,pc}
;;;501    
                          ENDP

000012  0000              DCW      0x0000
                  |L23.20|
                          DCD      0x40000400

                          AREA ||i.SignalSample_Sample_Timer_Init||, CODE, READONLY, ALIGN=2

                  SignalSample_Sample_Timer_Init PROC
;;;470    /******************************************************************************/
;;;471    void SignalSample_Sample_Timer_Init(void)
000000  b51f              PUSH     {r0-r4,lr}
;;;472    {
;;;473    	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
;;;474    	NVIC_InitTypeDef NVIC_InitStructure;
;;;475    
;;;476    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
000002  2101              MOVS     r1,#1
000004  2002              MOVS     r0,#2
000006  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;477    
;;;478    	TIM_TimeBaseStructure.TIM_Period = ADC_TIMER_PERIOD;
00000a  203c              MOVS     r0,#0x3c
00000c  f8ad0008          STRH     r0,[sp,#8]
;;;479    	TIM_TimeBaseStructure.TIM_Prescaler = ADC_TIMER_PRESCALER;
000010  f641401f          MOV      r0,#0x1c1f
000014  f8ad0004          STRH     r0,[sp,#4]
;;;480    	TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;
000018  2000              MOVS     r0,#0
00001a  f8ad000a          STRH     r0,[sp,#0xa]
;;;481    	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
00001e  f8ad0006          STRH     r0,[sp,#6]
;;;482    	TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);
000022  a901              ADD      r1,sp,#4
000024  480c              LDR      r0,|L24.88|
000026  f7fffffe          BL       TIM_TimeBaseInit
;;;483    
;;;484    	NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn;
00002a  201d              MOVS     r0,#0x1d
00002c  f88d0000          STRB     r0,[sp,#0]
;;;485    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
000030  2000              MOVS     r0,#0
000032  f88d0001          STRB     r0,[sp,#1]
;;;486    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;
000036  2003              MOVS     r0,#3
000038  f88d0002          STRB     r0,[sp,#2]
;;;487    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00003c  2001              MOVS     r0,#1
00003e  f88d0003          STRB     r0,[sp,#3]
;;;488    	NVIC_Init(&NVIC_InitStructure);
000042  4668              MOV      r0,sp
000044  f7fffffe          BL       NVIC_Init
;;;489    
;;;490    	TIM_Cmd(TIM3, ENABLE);
000048  2101              MOVS     r1,#1
00004a  4803              LDR      r0,|L24.88|
00004c  f7fffffe          BL       TIM_Cmd
;;;491    
;;;492    	SignalSample_Sample_Timer_Int(ENABLE);
000050  2001              MOVS     r0,#1
000052  f7fffffe          BL       SignalSample_Sample_Timer_Int
;;;493    }
000056  bd1f              POP      {r0-r4,pc}
;;;494    
                          ENDP

                  |L24.88|
                          DCD      0x40000400

                          AREA ||i.SignalSample_Sample_Timer_Int||, CODE, READONLY, ALIGN=2

                  SignalSample_Sample_Timer_Int PROC
;;;502    /******************************************************************************/
;;;503    void SignalSample_Sample_Timer_Int(FunctionalState state)
000000  b510              PUSH     {r4,lr}
;;;504    {
000002  4604              MOV      r4,r0
;;;505    	TIM_ITConfig(TIM3, TIM_IT_Update, state);
000004  4622              MOV      r2,r4
000006  2101              MOVS     r1,#1
000008  4801              LDR      r0,|L25.16|
00000a  f7fffffe          BL       TIM_ITConfig
;;;506    }
00000e  bd10              POP      {r4,pc}
;;;507    
                          ENDP

                  |L25.16|
                          DCD      0x40000400

                          AREA ||i.SignalSample_Sample_Vbat||, CODE, READONLY, ALIGN=1

                  SignalSample_Sample_Vbat PROC
;;;341    /******************************************************************************/
;;;342    vu16 SignalSample_Sample_Vbat(void)
000000  b510              PUSH     {r4,lr}
;;;343    {
;;;344    	return SignalSample_Sample_Sampling(ADC_CH_VBAT, VBAT_SAMPLE_NUM);
000002  2132              MOVS     r1,#0x32
000004  200b              MOVS     r0,#0xb
000006  f7fffffe          BL       SignalSample_Sample_Sampling
;;;345    }
00000a  bd10              POP      {r4,pc}
;;;346    
                          ENDP


                          AREA ||i.SignalSample_SetResistor||, CODE, READONLY, ALIGN=2

                  SignalSample_SetResistor PROC
;;;302    ******************************************************************************/
;;;303    void SignalSample_SetResistor(u8 channel, u8 data)
000000  b570              PUSH     {r4-r6,lr}
;;;304    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;305    	SIGNALSAMPLE_AD84XX_CS_Enable();
000006  2110              MOVS     r1,#0x10
000008  4809              LDR      r0,|L27.48|
00000a  f7fffffe          BL       GPIO_ResetBits
;;;306    	Delay_ms(SIGNALSAMPLE_AD84XX_DEALYREF);
00000e  2064              MOVS     r0,#0x64
000010  f7fffffe          BL       Delay_ms
;;;307    	SignalSample_Sample_AD84XX_SendByte(channel);
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       SignalSample_Sample_AD84XX_SendByte
;;;308    	SignalSample_Sample_AD84XX_SendByte(data);
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       SignalSample_Sample_AD84XX_SendByte
;;;309    	Delay_ms(SIGNALSAMPLE_AD84XX_DEALYREF);
000020  2064              MOVS     r0,#0x64
000022  f7fffffe          BL       Delay_ms
;;;310    	SIGNALSAMPLE_AD84XX_CS_Disable();
000026  2110              MOVS     r1,#0x10
000028  4801              LDR      r0,|L27.48|
00002a  f7fffffe          BL       GPIO_SetBits
;;;311    }
00002e  bd70              POP      {r4-r6,pc}
;;;312    
                          ENDP

                  |L27.48|
                          DCD      0x40010800

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  SignalProcess_sampleBuffer
                          %        20
                  SignalProcess_sampleBuffer_BK
                          %        20
                  SignalProcess_outputBuffer
                          %        10

                          AREA ||.data||, DATA, ALIGN=1

                  SignalSample_moveThenSample
000000  00                DCB      0x00
                  SignalSample_endDetection
000001  00                DCB      0x00
                  SignalSample_count
000002  0000              DCW      0x0000
                  SignalSample_ProcessCount
000004  0000              DCW      0x0000
                  SignalSample_startSampling
000006  00                DCB      0x00
                  SignalSample_resistorValue
000007  00                DCB      0x00
                  SignalSample_resistorValueStored
000008  00                DCB      0x00
                  SignalProcess_output
000009  00                DCB      0x00
