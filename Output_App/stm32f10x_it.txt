; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\Output_App\stm32f10x_it.o --asm_dir=..\Output_App\ --list_dir=..\Output_App\ --depend=..\Output_App\stm32f10x_it.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=870 -I.\System\CM3 -I.\System\FWlib\inc -I.\System\Startup -I.\ISR -I.\Main -I.\Management\DisplayDriver -I.\Management\HumanInput -I.\Management\Interface -I.\Management\RotationMotor -I.\Management\ScanMotor -I.\Management\Common_CRC -I.\Management\QRCode -I.\Management\SystemManage_RTC -I.\Management\SignalProcess_Sample -I.\USB -I.\USB\comm -I.\USB\lib -I.\USB\src -I.\USB\USB_Communication -ID:\Keil4.0\ARM\RV31\Inc -ID:\Keil4.0\ARM\CMSIS\Include -ID:\Keil4.0\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DUSE_STM3210E_EVAL -W --omf_browse=..\Output_App\stm32f10x_it.crf ISR\stm32f10x_it.c]
                          THUMB

                          AREA ||i.BusFault_Handler||, CODE, READONLY, ALIGN=1

                  BusFault_Handler PROC
;;;50     /******************************************************************************/
;;;51     void BusFault_Handler(void)
000000  bf00              NOP      
                  |L1.2|
;;;52     {
;;;53       /* Go to infinite loop when Bus Fault exception occurs */
;;;54       while (1)
000002  e7fe              B        |L1.2|
;;;55       {
;;;56       }
;;;57     }
;;;58     
                          ENDP


                          AREA ||i.DebugMon_Handler||, CODE, READONLY, ALIGN=1

                  DebugMon_Handler PROC
;;;73     /******************************************************************************/
;;;74     void DebugMon_Handler(void)
000000  4770              BX       lr
;;;75     {
;;;76     }
;;;77     
                          ENDP


                          AREA ||i.Delay_ms_SW||, CODE, READONLY, ALIGN=1

                  Delay_ms_SW PROC
;;;16     /******************************************************************************/
;;;17     void Delay_ms_SW(__IO uint32 nCount)
000000  e006              B        |L3.16|
                  |L3.2|
;;;18     {
;;;19     #define SW_72MHZ_1MS_COUNT (0x27FF)
;;;20     	uint32 subCount;
;;;21     	for(; nCount != 0; nCount--)
;;;22     	{
;;;23     		subCount = SW_72MHZ_1MS_COUNT;
000002  f24271ff          MOV      r1,#0x27ff
;;;24     		for(; subCount != 0; subCount--);
000006  e000              B        |L3.10|
                  |L3.8|
000008  1e49              SUBS     r1,r1,#1
                  |L3.10|
00000a  2900              CMP      r1,#0
00000c  d1fc              BNE      |L3.8|
00000e  1e40              SUBS     r0,r0,#1              ;21
                  |L3.16|
000010  2800              CMP      r0,#0                 ;21
000012  d1f6              BNE      |L3.2|
;;;25     	}
;;;26     }
000014  4770              BX       lr
;;;27     /********************************************************************************/
                          ENDP


                          AREA ||i.EXTI0_IRQHandler||, CODE, READONLY, ALIGN=1

                  EXTI0_IRQHandler PROC
;;;159    /******************************************************************************/
;;;160    void EXTI0_IRQHandler(void)
000000  4770              BX       lr
;;;161    {
;;;162    
;;;163    }
;;;164    
                          ENDP


                          AREA ||i.EXTI15_10_IRQHandler||, CODE, READONLY, ALIGN=1

                  EXTI15_10_IRQHandler PROC
;;;228    /******************************************************************************/
;;;229    void EXTI15_10_IRQHandler(void)
000000  4770              BX       lr
;;;230    {
;;;231    }
;;;232    
                          ENDP


                          AREA ||i.EXTI1_IRQHandler||, CODE, READONLY, ALIGN=2

                  EXTI1_IRQHandler PROC
;;;165    /******************************************************************************/
;;;166    void EXTI1_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;167    {
;;;168    	ScanMotorDriver_InBasePosition = 1;
000002  2001              MOVS     r0,#1
000004  4903              LDR      r1,|L6.20|
000006  7008              STRB     r0,[r1,#0]
;;;169    	ScanMotorDriver_PositionSensor_Int_Disable();
000008  f7fffffe          BL       ScanMotorDriver_PositionSensor_Int_Disable
;;;170    	EXTI_ClearITPendingBit(EXTI_Line1);		 		//清除LINE1上的中断标志位
00000c  2002              MOVS     r0,#2
00000e  f7fffffe          BL       EXTI_ClearITPendingBit
;;;171    }
000012  bd10              POP      {r4,pc}
;;;172    
                          ENDP

                  |L6.20|
                          DCD      ScanMotorDriver_InBasePosition

                          AREA ||i.EXTI2_IRQHandler||, CODE, READONLY, ALIGN=1

                  EXTI2_IRQHandler PROC
;;;173    /******************************************************************************/
;;;174    void EXTI2_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;175    {
;;;176    	RotaMotorDriver_PositionSensor_Int_Disable();
000002  f7fffffe          BL       RotaMotorDriver_PositionSensor_Int_Disable
;;;177    	EXTI_ClearITPendingBit(EXTI_Line2);			 	//清除LINE2上的中断标志位
000006  2004              MOVS     r0,#4
000008  f7fffffe          BL       EXTI_ClearITPendingBit
;;;178    }
00000c  bd10              POP      {r4,pc}
;;;179    
                          ENDP


                          AREA ||i.EXTI3_IRQHandler||, CODE, READONLY, ALIGN=1

                  EXTI3_IRQHandler PROC
;;;180    /******************************************************************************/
;;;181    void EXTI3_IRQHandler(void)
000000  4770              BX       lr
;;;182    {
;;;183    }
;;;184    
                          ENDP


                          AREA ||i.EXTI4_IRQHandler||, CODE, READONLY, ALIGN=2

                  EXTI4_IRQHandler PROC
;;;185    /******************************************************************************/
;;;186    void EXTI4_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;187    {
;;;188    	if(Exti_lock)
000002  4809              LDR      r0,|L9.40|
000004  7800              LDRB     r0,[r0,#0]  ; Exti_lock
000006  b158              CBZ      r0,|L9.32|
;;;189    	{
;;;190    		if(EXTI_GetITStatus(EXTI_Line4))	 		//向右按键
000008  2010              MOVS     r0,#0x10
00000a  f7fffffe          BL       EXTI_GetITStatus
00000e  b138              CBZ      r0,|L9.32|
;;;191    		{
;;;192    			key_fall_flag = 1;						//确认按键
000010  2001              MOVS     r0,#1
000012  4906              LDR      r1,|L9.44|
000014  7008              STRB     r0,[r1,#0]
;;;193    			EXTI_ClearITPendingBit(EXTI_Line4);		//清除LINE4上的中断标志位
000016  2010              MOVS     r0,#0x10
000018  f7fffffe          BL       EXTI_ClearITPendingBit
;;;194    			EXTI_Key_Confirm_Disable();
00001c  f7fffffe          BL       EXTI_Key_Confirm_Disable
                  |L9.32|
;;;195    		}
;;;196    	}
;;;197    	EXTI_ClearITPendingBit(EXTI_Line4);			 	//清除LINE4上的中断标志位
000020  2010              MOVS     r0,#0x10
000022  f7fffffe          BL       EXTI_ClearITPendingBit
;;;198    }
000026  bd10              POP      {r4,pc}
;;;199    
                          ENDP

                  |L9.40|
                          DCD      Exti_lock
                  |L9.44|
                          DCD      key_fall_flag

                          AREA ||i.EXTI9_5_IRQHandler||, CODE, READONLY, ALIGN=2

                  EXTI9_5_IRQHandler PROC
;;;200    /******************************************************************************/
;;;201    void EXTI9_5_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;202    {	 
;;;203    	if(Exti_lock)
000002  4817              LDR      r0,|L10.96|
000004  7800              LDRB     r0,[r0,#0]  ; Exti_lock
000006  b310              CBZ      r0,|L10.78|
;;;204    	{
;;;205    		if(EXTI_GetITStatus(EXTI_Line8))	 		//向右按键
000008  f44f7080          MOV      r0,#0x100
00000c  f7fffffe          BL       EXTI_GetITStatus
000010  b148              CBZ      r0,|L10.38|
;;;206    		{
;;;207    			Delay_ms_SW(Time_ms);
000012  20b4              MOVS     r0,#0xb4
000014  f7fffffe          BL       Delay_ms_SW
;;;208    			if(EXTI_GetITStatus(EXTI_Line8))	 	//向右按键
000018  f44f7080          MOV      r0,#0x100
00001c  f7fffffe          BL       EXTI_GetITStatus
000020  b108              CBZ      r0,|L10.38|
;;;209    			{
;;;210    				Key_Right();
000022  f7fffffe          BL       Key_Right
                  |L10.38|
;;;211    			}
;;;212    		}
;;;213    
;;;214    		if(EXTI_GetITStatus(EXTI_Line9))	 		//向右按键
000026  f44f7000          MOV      r0,#0x200
00002a  f7fffffe          BL       EXTI_GetITStatus
00002e  b170              CBZ      r0,|L10.78|
;;;215    		{
;;;216    			Delay_ms_SW(Time_ms);
000030  20b4              MOVS     r0,#0xb4
000032  f7fffffe          BL       Delay_ms_SW
;;;217    			if(EXTI_GetITStatus(EXTI_Line9))	 	//向左按键
000036  f44f7000          MOV      r0,#0x200
00003a  f7fffffe          BL       EXTI_GetITStatus
00003e  b108              CBZ      r0,|L10.68|
;;;218    			{
;;;219    				Key_Left();
000040  f7fffffe          BL       Key_Left
                  |L10.68|
;;;220    			}
;;;221    			se_count += Time_ms;
000044  4807              LDR      r0,|L10.100|
000046  8800              LDRH     r0,[r0,#0]  ; se_count
000048  30b4              ADDS     r0,r0,#0xb4
00004a  4906              LDR      r1,|L10.100|
00004c  8008              STRH     r0,[r1,#0]
                  |L10.78|
;;;222    		}
;;;223    	}
;;;224    	EXTI_ClearITPendingBit(EXTI_Line8);  			//清除LINE8上的中断标志位
00004e  f44f7080          MOV      r0,#0x100
000052  f7fffffe          BL       EXTI_ClearITPendingBit
;;;225    	EXTI_ClearITPendingBit(EXTI_Line9);  			//清除LINE9上的中断标志位
000056  f44f7000          MOV      r0,#0x200
00005a  f7fffffe          BL       EXTI_ClearITPendingBit
;;;226    }
00005e  bd10              POP      {r4,pc}
;;;227    
                          ENDP

                  |L10.96|
                          DCD      Exti_lock
                  |L10.100|
                          DCD      se_count

                          AREA ||i.HardFault_Handler||, CODE, READONLY, ALIGN=1

                  HardFault_Handler PROC
;;;32     /******************************************************************************/
;;;33     void HardFault_Handler(void)
000000  bf00              NOP      
                  |L11.2|
;;;34     {
;;;35     	/* Go to infinite loop when Hard Fault exception occurs */
;;;36     	while (1)
000002  e7fe              B        |L11.2|
;;;37     	{
;;;38     	}
;;;39     }
;;;40     
                          ENDP


                          AREA ||i.MemManage_Handler||, CODE, READONLY, ALIGN=1

                  MemManage_Handler PROC
;;;41     /******************************************************************************/
;;;42     void MemManage_Handler(void)
000000  bf00              NOP      
                  |L12.2|
;;;43     {
;;;44       /* Go to infinite loop when Memory Manage exception occurs */
;;;45       while (1)
000002  e7fe              B        |L12.2|
;;;46       {
;;;47       }
;;;48     }
;;;49     
                          ENDP


                          AREA ||i.NMI_Handler||, CODE, READONLY, ALIGN=1

                  NMI_Handler PROC
;;;27     /********************************************************************************/
;;;28     void NMI_Handler(void)
000000  4770              BX       lr
;;;29     {
;;;30     }
;;;31     
                          ENDP


                          AREA ||i.PVD_IRQHandler||, CODE, READONLY, ALIGN=1

                  PVD_IRQHandler PROC
;;;233    /******************************************************************************/
;;;234    void PVD_IRQHandler(void)
000000  4770              BX       lr
;;;235    {
;;;236    }
                          ENDP


                          AREA ||i.PendSV_Handler||, CODE, READONLY, ALIGN=1

                  PendSV_Handler PROC
;;;78     /******************************************************************************/
;;;79     void PendSV_Handler(void)
000000  4770              BX       lr
;;;80     {
;;;81     }
;;;82     
                          ENDP


                          AREA ||i.SVC_Handler||, CODE, READONLY, ALIGN=1

                  SVC_Handler PROC
;;;68     /******************************************************************************/
;;;69     void SVC_Handler(void)
000000  4770              BX       lr
;;;70     {
;;;71     }
;;;72     
                          ENDP


                          AREA ||i.SysTick_Handler||, CODE, READONLY, ALIGN=2

                  SysTick_Handler PROC
;;;83     /******************************************************************************/
;;;84     void SysTick_Handler(void)
000000  b510              PUSH     {r4,lr}
;;;85     {
;;;86     	TimingDelay_Decrement();						/* Decrease TimingDelay */
000002  f7fffffe          BL       TimingDelay_Decrement
;;;87     	se_count++;     								//秒钟计数自增
000006  4827              LDR      r0,|L17.164|
000008  8800              LDRH     r0,[r0,#0]  ; se_count
00000a  1c40              ADDS     r0,r0,#1
00000c  4925              LDR      r1,|L17.164|
00000e  8008              STRH     r0,[r1,#0]
;;;88     	if(se_count > 99)   							//1秒钟进入一次
000010  4608              MOV      r0,r1
000012  8800              LDRH     r0,[r0,#0]  ; se_count
000014  2863              CMP      r0,#0x63
000016  dd07              BLE      |L17.40|
;;;89     	{
;;;90     		if(Display_Time)
000018  4823              LDR      r0,|L17.168|
00001a  7800              LDRB     r0,[r0,#0]  ; Display_Time
00001c  b108              CBZ      r0,|L17.34|
;;;91     		{
;;;92     			UI_Draw_Status_Bar();
00001e  f7fffffe          BL       UI_Draw_Status_Bar
                  |L17.34|
;;;93     		}
;;;94     		se_count = 0;								//重新定时1秒钟
000022  2000              MOVS     r0,#0
000024  491f              LDR      r1,|L17.164|
000026  8008              STRH     r0,[r1,#0]
                  |L17.40|
;;;95     	}
;;;96     
;;;97     	if(key_fall_flag==1)//发生按键按下事件
000028  4820              LDR      r0,|L17.172|
00002a  7800              LDRB     r0,[r0,#0]  ; key_fall_flag
00002c  2801              CMP      r0,#1
00002e  d136              BNE      |L17.158|
;;;98     	{
;;;99     		if(!GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_4))//按键持续按下
000030  2110              MOVS     r1,#0x10
000032  481f              LDR      r0,|L17.176|
000034  f7fffffe          BL       GPIO_ReadInputDataBit
000038  b9b0              CBNZ     r0,|L17.104|
;;;100    		{
;;;101    			if(key_holdon_ms < 2000)
00003a  481e              LDR      r0,|L17.180|
00003c  8800              LDRH     r0,[r0,#0]  ; key_holdon_ms
00003e  f5b06ffa          CMP      r0,#0x7d0
000042  da05              BGE      |L17.80|
;;;102    			{
;;;103    				key_holdon_ms++;
000044  481b              LDR      r0,|L17.180|
000046  8800              LDRH     r0,[r0,#0]  ; key_holdon_ms
000048  1c40              ADDS     r0,r0,#1
00004a  491a              LDR      r1,|L17.180|
00004c  8008              STRH     r0,[r1,#0]
00004e  e026              B        |L17.158|
                  |L17.80|
;;;104    			}
;;;105    			else 									//按键按下到2000ms就判断长按时间成立，生成长按标志
;;;106    			{
;;;107    				key_holdon_ms = 0;
000050  2000              MOVS     r0,#0
000052  4918              LDR      r1,|L17.180|
000054  8008              STRH     r0,[r1,#0]
;;;108    				short_key_flag=0;					//清短按键标志
000056  4918              LDR      r1,|L17.184|
000058  7008              STRB     r0,[r1,#0]
;;;109    				long_key_flag = 1;					//长按键标志置位
00005a  2001              MOVS     r0,#1
00005c  4917              LDR      r1,|L17.188|
00005e  7008              STRB     r0,[r1,#0]
;;;110    				key_fall_flag = 0;					//清按键按下标志
000060  2000              MOVS     r0,#0
000062  4912              LDR      r1,|L17.172|
000064  7008              STRB     r0,[r1,#0]
000066  e01a              B        |L17.158|
                  |L17.104|
;;;111    			}
;;;112    		}
;;;113    		else 										//按键抬起
;;;114    		{
;;;115    			if(key_holdon_ms > 50)					//按下时间大于50ms，生成单击标志
000068  4812              LDR      r0,|L17.180|
00006a  8800              LDRH     r0,[r0,#0]  ; key_holdon_ms
00006c  2832              CMP      r0,#0x32
00006e  dd0b              BLE      |L17.136|
;;;116    			{
;;;117    				key_holdon_ms=0;
000070  2000              MOVS     r0,#0
000072  4910              LDR      r1,|L17.180|
000074  8008              STRH     r0,[r1,#0]
;;;118    				short_key_flag=1;
000076  2001              MOVS     r0,#1
000078  490f              LDR      r1,|L17.184|
00007a  7008              STRB     r0,[r1,#0]
;;;119    				long_key_flag =0;
00007c  2000              MOVS     r0,#0
00007e  490f              LDR      r1,|L17.188|
000080  7008              STRB     r0,[r1,#0]
;;;120    				key_fall_flag=0;
000082  490a              LDR      r1,|L17.172|
000084  7008              STRB     r0,[r1,#0]
000086  e00a              B        |L17.158|
                  |L17.136|
;;;121    			}
;;;122    			else  									//按键持续时间小于50ms，忽略
;;;123    			{
;;;124    				key_holdon_ms=0;
000088  2000              MOVS     r0,#0
00008a  490a              LDR      r1,|L17.180|
00008c  8008              STRH     r0,[r1,#0]
;;;125    				short_key_flag=0;
00008e  490a              LDR      r1,|L17.184|
000090  7008              STRB     r0,[r1,#0]
;;;126    				long_key_flag=0;
000092  490a              LDR      r1,|L17.188|
000094  7008              STRB     r0,[r1,#0]
;;;127    				key_fall_flag=0;
000096  4905              LDR      r1,|L17.172|
000098  7008              STRB     r0,[r1,#0]
;;;128    				EXTI_Key_Confirm_Enable();
00009a  f7fffffe          BL       EXTI_Key_Confirm_Enable
                  |L17.158|
;;;129    			}
;;;130    		}
;;;131    	}
;;;132    
;;;133    	Key_Confirm();									//此函数决不能有延时
00009e  f7fffffe          BL       Key_Confirm
;;;134    }
0000a2  bd10              POP      {r4,pc}
;;;135    
                          ENDP

                  |L17.164|
                          DCD      se_count
                  |L17.168|
                          DCD      Display_Time
                  |L17.172|
                          DCD      key_fall_flag
                  |L17.176|
                          DCD      0x40010c00
                  |L17.180|
                          DCD      key_holdon_ms
                  |L17.184|
                          DCD      short_key_flag
                  |L17.188|
                          DCD      long_key_flag

                          AREA ||i.TIM3_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM3_IRQHandler PROC
;;;136    /******************************************************************************/
;;;137    void TIM3_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;138    {
;;;139    	if (TIM_GetITStatus(TIM3, TIM_IT_Update) != RESET)
000002  2101              MOVS     r1,#1
000004  4807              LDR      r0,|L18.36|
000006  f7fffffe          BL       TIM_GetITStatus
00000a  b130              CBZ      r0,|L18.26|
;;;140    	{
;;;141    		TIM_ClearITPendingBit(TIM3, TIM_IT_Update);
00000c  2101              MOVS     r1,#1
00000e  4805              LDR      r0,|L18.36|
000010  f7fffffe          BL       TIM_ClearITPendingBit
;;;142    		SignalSample_moveThenSample = 1;
000014  2001              MOVS     r0,#1
000016  4904              LDR      r1,|L18.40|
000018  7008              STRB     r0,[r1,#0]
                  |L18.26|
;;;143    	}
;;;144    
;;;145    	TIM_ClearITPendingBit(TIM3, ENABLE ); 			//清除 TIM3 更新中断标志
00001a  2101              MOVS     r1,#1
00001c  4801              LDR      r0,|L18.36|
00001e  f7fffffe          BL       TIM_ClearITPendingBit
;;;146    }
000022  bd10              POP      {r4,pc}
;;;147    
                          ENDP

                  |L18.36|
                          DCD      0x40000400
                  |L18.40|
                          DCD      SignalSample_moveThenSample

                          AREA ||i.TIM4_IRQHandler||, CODE, READONLY, ALIGN=1

                  TIM4_IRQHandler PROC
;;;148    /******************************************************************************/
;;;149    void TIM4_IRQHandler(void)
000000  4770              BX       lr
;;;150    {
;;;151    }
;;;152    
                          ENDP


                          AREA ||i.TIM7_IRQHandler||, CODE, READONLY, ALIGN=1

                  TIM7_IRQHandler PROC
;;;153    /******************************************************************************/
;;;154    void TIM7_IRQHandler(void)
000000  4770              BX       lr
;;;155    {
;;;156    
;;;157    }
;;;158    
                          ENDP


                          AREA ||i.UsageFault_Handler||, CODE, READONLY, ALIGN=1

                  UsageFault_Handler PROC
;;;59     /******************************************************************************/
;;;60     void UsageFault_Handler(void)
000000  bf00              NOP      
                  |L21.2|
;;;61     {
;;;62       /* Go to infinite loop when Usage Fault exception occurs */
;;;63       while (1)
000002  e7fe              B        |L21.2|
;;;64       {
;;;65       }
;;;66     }
;;;67     
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  tbuf1
                          %        10

                          AREA ||.data||, DATA, ALIGN=1

                  Count_Down
000000  0000              DCW      0x0000
                  Exti_lock
000002  0000              DCB      0x00,0x00
                  hours
000004  000b              DCW      0x000b
                  minutes
000006  000b              DCW      0x000b
                  seconds
000008  0001              DCW      0x0001
                  se_count
00000a  0000              DCW      0x0000
                  keyupCnt
00000c  0000              DCW      0x0000
                  key_holdon_ms
00000e  0000              DCW      0x0000
                  key_fall_flag
000010  00                DCB      0x00
                  short_key_flag
000011  00                DCB      0x00
                  doubleClick
000012  00                DCB      0x00
                  keyUpFlag
000013  00                DCB      0x00
                  long_key_flag
000014  0000              DCB      0x00,0x00
                  time_ms
000016  0000              DCW      0x0000
