; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\Output_App\usb_pwr.o --asm_dir=..\Output_App\ --list_dir=..\Output_App\ --depend=..\Output_App\usb_pwr.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=870 -I.\System\CM3 -I.\System\FWlib\inc -I.\System\Startup -I.\ISR -I.\Main -I.\Management\DisplayDriver -I.\Management\HumanInput -I.\Management\Interface -I.\Management\RotationMotor -I.\Management\ScanMotor -I.\Management\Common_CRC -I.\Management\QRCode -I.\Management\SystemManage_RTC -I.\Management\SignalProcess_Sample -I.\USB -I.\USB\comm -I.\USB\lib -I.\USB\src -I.\USB\USB_Communication -ID:\Keil4.0\ARM\RV31\Inc -ID:\Keil4.0\ARM\CMSIS\Include -ID:\Keil4.0\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DUSE_STM3210E_EVAL -W --omf_browse=..\Output_App\usb_pwr.crf USB\src\usb_pwr.c]
                          THUMB

                          AREA ||i.PowerOff||, CODE, READONLY, ALIGN=2

                  PowerOff PROC
;;;93     *******************************************************************************/
;;;94     RESULT PowerOff()
000000  b510              PUSH     {r4,lr}
;;;95     {
;;;96       /* disable all interrupts and force USB reset */
;;;97       _SetCNTR(CNTR_FRES);
000002  2001              MOVS     r0,#1
000004  4905              LDR      r1,|L1.28|
000006  6008              STR      r0,[r1,#0]
;;;98       /* clear interrupt status register */
;;;99       _SetISTR(0);
000008  2000              MOVS     r0,#0
00000a  1d09              ADDS     r1,r1,#4
00000c  6008              STR      r0,[r1,#0]
;;;100      /* Disable the Pull-Up*/
;;;101      USB_Cable_Config(DISABLE);
00000e  f7fffffe          BL       USB_Cable_Config
;;;102      /* switch-off device */
;;;103      _SetCNTR(CNTR_FRES + CNTR_PDWN);
000012  2003              MOVS     r0,#3
000014  4901              LDR      r1,|L1.28|
000016  6008              STR      r0,[r1,#0]
;;;104      /* sw variables reset */
;;;105      /* ... */
;;;106    
;;;107      return USB_SUCCESS;
000018  2000              MOVS     r0,#0
;;;108    }
00001a  bd10              POP      {r4,pc}
;;;109    
                          ENDP

                  |L1.28|
                          DCD      0x40005c40

                          AREA ||i.PowerOn||, CODE, READONLY, ALIGN=2

                  PowerOn PROC
;;;63     *******************************************************************************/
;;;64     RESULT PowerOn(void)
000000  b510              PUSH     {r4,lr}
;;;65     {
;;;66       uint16_t wRegVal;
;;;67     
;;;68       /*** cable plugged-in ? ***/
;;;69       USB_Cable_Config(ENABLE);
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       USB_Cable_Config
;;;70     
;;;71       /*** CNTR_PWDN = 0 ***/
;;;72       wRegVal = CNTR_FRES;
000008  2401              MOVS     r4,#1
;;;73       _SetCNTR(wRegVal);
00000a  480b              LDR      r0,|L2.56|
00000c  6004              STR      r4,[r0,#0]
;;;74     
;;;75       /*** CNTR_FRES = 0 ***/
;;;76       wInterrupt_Mask = 0;
00000e  2000              MOVS     r0,#0
000010  490a              LDR      r1,|L2.60|
000012  8008              STRH     r0,[r1,#0]
;;;77       _SetCNTR(wInterrupt_Mask);
000014  4608              MOV      r0,r1
000016  8800              LDRH     r0,[r0,#0]  ; wInterrupt_Mask
000018  4907              LDR      r1,|L2.56|
00001a  6008              STR      r0,[r1,#0]
;;;78       /*** Clear pending interrupts ***/
;;;79       _SetISTR(0);
00001c  2000              MOVS     r0,#0
00001e  1d09              ADDS     r1,r1,#4
000020  6008              STR      r0,[r1,#0]
;;;80       /*** Set interrupt mask ***/
;;;81       wInterrupt_Mask = CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM;
000022  f44f50e0          MOV      r0,#0x1c00
000026  4905              LDR      r1,|L2.60|
000028  8008              STRH     r0,[r1,#0]
;;;82       _SetCNTR(wInterrupt_Mask);
00002a  4608              MOV      r0,r1
00002c  8800              LDRH     r0,[r0,#0]  ; wInterrupt_Mask
00002e  4902              LDR      r1,|L2.56|
000030  6008              STR      r0,[r1,#0]
;;;83       
;;;84       return USB_SUCCESS;
000032  2000              MOVS     r0,#0
;;;85     }
000034  bd10              POP      {r4,pc}
;;;86     
                          ENDP

000036  0000              DCW      0x0000
                  |L2.56|
                          DCD      0x40005c40
                  |L2.60|
                          DCD      wInterrupt_Mask

                          AREA ||i.Resume||, CODE, READONLY, ALIGN=2

                  Resume PROC
;;;258    *******************************************************************************/
;;;259    void Resume(RESUME_STATE eResumeSetVal)
000000  b570              PUSH     {r4-r6,lr}
;;;260    {
000002  4605              MOV      r5,r0
;;;261      uint16_t wCNTR;
;;;262    
;;;263      if (eResumeSetVal != RESUME_ESOF)
000004  2d07              CMP      r5,#7
000006  d001              BEQ      |L3.12|
;;;264        ResumeS.eState = eResumeSetVal;
000008  482e              LDR      r0,|L3.196|
00000a  7005              STRB     r5,[r0,#0]
                  |L3.12|
;;;265      switch (ResumeS.eState)
00000c  482d              LDR      r0,|L3.196|
00000e  7800              LDRB     r0,[r0,#0]  ; ResumeS
000010  2808              CMP      r0,#8
000012  d24e              BCS      |L3.178|
000014  e8dff000          TBB      [pc,r0]
000018  04111a20          DCB      0x04,0x11,0x1a,0x20
00001c  2b384e4f          DCB      0x2b,0x38,0x4e,0x4f
;;;266      {
;;;267        case RESUME_EXTERNAL:
;;;268          if (remotewakeupon ==0)
000020  4829              LDR      r0,|L3.200|
000022  6800              LDR      r0,[r0,#0]  ; remotewakeupon
000024  b928              CBNZ     r0,|L3.50|
;;;269          {
;;;270            Resume_Init();
000026  f7fffffe          BL       Resume_Init
;;;271            ResumeS.eState = RESUME_OFF;
00002a  2006              MOVS     r0,#6
00002c  4925              LDR      r1,|L3.196|
00002e  7008              STRB     r0,[r1,#0]
000030  e002              B        |L3.56|
                  |L3.50|
;;;272          }
;;;273          else /* RESUME detected during the RemoteWAkeup signalling => keep RemoteWakeup handling*/
;;;274          {
;;;275            ResumeS.eState = RESUME_ON;
000032  2005              MOVS     r0,#5
000034  4923              LDR      r1,|L3.196|
000036  7008              STRB     r0,[r1,#0]
                  |L3.56|
;;;276          }
;;;277          break;
000038  e041              B        |L3.190|
;;;278        case RESUME_INTERNAL:
;;;279          Resume_Init();
00003a  f7fffffe          BL       Resume_Init
;;;280          ResumeS.eState = RESUME_START;
00003e  2004              MOVS     r0,#4
000040  4920              LDR      r1,|L3.196|
000042  7008              STRB     r0,[r1,#0]
;;;281          remotewakeupon = 1;
000044  2001              MOVS     r0,#1
000046  4920              LDR      r1,|L3.200|
000048  6008              STR      r0,[r1,#0]  ; remotewakeupon
;;;282          break;
00004a  e038              B        |L3.190|
;;;283        case RESUME_LATER:
;;;284          ResumeS.bESOFcnt = 2;
00004c  2002              MOVS     r0,#2
00004e  491d              LDR      r1,|L3.196|
000050  7048              STRB     r0,[r1,#1]
;;;285          ResumeS.eState = RESUME_WAIT;
000052  2003              MOVS     r0,#3
000054  7008              STRB     r0,[r1,#0]
;;;286          break;
000056  e032              B        |L3.190|
;;;287        case RESUME_WAIT:
;;;288          ResumeS.bESOFcnt--;
000058  481a              LDR      r0,|L3.196|
00005a  7840              LDRB     r0,[r0,#1]  ; ResumeS
00005c  1e40              SUBS     r0,r0,#1
00005e  4919              LDR      r1,|L3.196|
000060  7048              STRB     r0,[r1,#1]
;;;289          if (ResumeS.bESOFcnt == 0)
000062  4608              MOV      r0,r1
000064  7840              LDRB     r0,[r0,#1]  ; ResumeS
000066  b908              CBNZ     r0,|L3.108|
;;;290            ResumeS.eState = RESUME_START;
000068  2004              MOVS     r0,#4
00006a  7008              STRB     r0,[r1,#0]
                  |L3.108|
;;;291          break;
00006c  e027              B        |L3.190|
;;;292        case RESUME_START:
;;;293          wCNTR = _GetCNTR();
00006e  4817              LDR      r0,|L3.204|
000070  6800              LDR      r0,[r0,#0]
000072  b284              UXTH     r4,r0
;;;294          wCNTR |= CNTR_RESUME;
000074  f0440410          ORR      r4,r4,#0x10
;;;295          _SetCNTR(wCNTR);
000078  4814              LDR      r0,|L3.204|
00007a  6004              STR      r4,[r0,#0]
;;;296          ResumeS.eState = RESUME_ON;
00007c  2005              MOVS     r0,#5
00007e  4911              LDR      r1,|L3.196|
000080  7008              STRB     r0,[r1,#0]
;;;297          ResumeS.bESOFcnt = 10;
000082  200a              MOVS     r0,#0xa
000084  7048              STRB     r0,[r1,#1]
;;;298          break;
000086  e01a              B        |L3.190|
;;;299        case RESUME_ON:    
;;;300          ResumeS.bESOFcnt--;
000088  480e              LDR      r0,|L3.196|
00008a  7840              LDRB     r0,[r0,#1]  ; ResumeS
00008c  1e40              SUBS     r0,r0,#1
00008e  490d              LDR      r1,|L3.196|
000090  7048              STRB     r0,[r1,#1]
;;;301          if (ResumeS.bESOFcnt == 0)
000092  4608              MOV      r0,r1
000094  7840              LDRB     r0,[r0,#1]  ; ResumeS
000096  b958              CBNZ     r0,|L3.176|
;;;302          {
;;;303            wCNTR = _GetCNTR();
000098  480c              LDR      r0,|L3.204|
00009a  6800              LDR      r0,[r0,#0]
00009c  b284              UXTH     r4,r0
;;;304            wCNTR &= (~CNTR_RESUME);
00009e  f0240410          BIC      r4,r4,#0x10
;;;305            _SetCNTR(wCNTR);
0000a2  480a              LDR      r0,|L3.204|
0000a4  6004              STR      r4,[r0,#0]
;;;306            ResumeS.eState = RESUME_OFF;
0000a6  2006              MOVS     r0,#6
0000a8  7008              STRB     r0,[r1,#0]
;;;307            remotewakeupon = 0;
0000aa  2000              MOVS     r0,#0
0000ac  4906              LDR      r1,|L3.200|
0000ae  6008              STR      r0,[r1,#0]  ; remotewakeupon
                  |L3.176|
;;;308          }
;;;309          break;
0000b0  e005              B        |L3.190|
                  |L3.178|
;;;310        case RESUME_OFF:
0000b2  bf00              NOP      
;;;311        case RESUME_ESOF:
0000b4  bf00              NOP      
;;;312        default:
;;;313          ResumeS.eState = RESUME_OFF;
0000b6  2006              MOVS     r0,#6
0000b8  4902              LDR      r1,|L3.196|
0000ba  7008              STRB     r0,[r1,#0]
;;;314          break;
0000bc  bf00              NOP      
                  |L3.190|
0000be  bf00              NOP                            ;277
;;;315      }
;;;316    }
0000c0  bd70              POP      {r4-r6,pc}
;;;317    
                          ENDP

0000c2  0000              DCW      0x0000
                  |L3.196|
                          DCD      ResumeS
                  |L3.200|
                          DCD      remotewakeupon
                  |L3.204|
                          DCD      0x40005c40

                          AREA ||i.Resume_Init||, CODE, READONLY, ALIGN=2

                  Resume_Init PROC
;;;221    *******************************************************************************/
;;;222    void Resume_Init(void)
000000  b510              PUSH     {r4,lr}
;;;223    {
;;;224      uint16_t wCNTR;
;;;225      
;;;226      /* ------------------ ONLY WITH BUS-POWERED DEVICES ---------------------- */
;;;227      /* restart the clocks */
;;;228      /* ...  */
;;;229    
;;;230      /* CNTR_LPMODE = 0 */
;;;231      wCNTR = _GetCNTR();
000002  4807              LDR      r0,|L4.32|
000004  6800              LDR      r0,[r0,#0]
000006  b284              UXTH     r4,r0
;;;232      wCNTR &= (~CNTR_LPMODE);
000008  f0240404          BIC      r4,r4,#4
;;;233      _SetCNTR(wCNTR);    
00000c  4804              LDR      r0,|L4.32|
00000e  6004              STR      r4,[r0,#0]
;;;234      
;;;235      /* restore full power */
;;;236      /* ... on connected devices */
;;;237      Leave_LowPowerMode();
000010  f7fffffe          BL       Leave_LowPowerMode
;;;238    
;;;239      /* reset FSUSP bit */
;;;240      _SetCNTR(IMR_MSK);
000014  f44f403f          MOV      r0,#0xbf00
000018  4901              LDR      r1,|L4.32|
00001a  6008              STR      r0,[r1,#0]
;;;241    
;;;242      /* reverse suspend preparation */
;;;243      /* ... */ 
;;;244    
;;;245    }
00001c  bd10              POP      {r4,pc}
;;;246    
                          ENDP

00001e  0000              DCW      0x0000
                  |L4.32|
                          DCD      0x40005c40

                          AREA ||i.Suspend||, CODE, READONLY, ALIGN=2

                  Suspend PROC
;;;116    *******************************************************************************/
;;;117    void Suspend(void)
000000  b530              PUSH     {r4,r5,lr}
;;;118    {
;;;119    	uint32_t i =0;
000002  2100              MOVS     r1,#0
;;;120    	uint16_t wCNTR;
;;;121    	uint32_t tmpreg = 0;
000004  2200              MOVS     r2,#0
;;;122      __IO uint32_t savePWR_CR=0;
000006  2300              MOVS     r3,#0
;;;123    	/* suspend preparation */
;;;124    	/* ... */
;;;125    	
;;;126    	/*Store CNTR value */
;;;127    	wCNTR = _GetCNTR();  
000008  4c35              LDR      r4,|L5.224|
00000a  6824              LDR      r4,[r4,#0]
00000c  b2a0              UXTH     r0,r4
;;;128    
;;;129        /* This a sequence to apply a force RESET to handle a robustness case */
;;;130        
;;;131    	/*Store endpoints registers status */
;;;132        for (i=0;i<8;i++) EP[i] = _GetENDPOINT(i);
00000e  bf00              NOP      
000010  e008              B        |L5.36|
                  |L5.18|
000012  4c33              LDR      r4,|L5.224|
000014  3c40              SUBS     r4,r4,#0x40
000016  f8544021          LDR      r4,[r4,r1,LSL #2]
00001a  b2a4              UXTH     r4,r4
00001c  4d31              LDR      r5,|L5.228|
00001e  f8454021          STR      r4,[r5,r1,LSL #2]
000022  1c49              ADDS     r1,r1,#1
                  |L5.36|
000024  2908              CMP      r1,#8
000026  d3f4              BCC      |L5.18|
;;;133    	
;;;134    	/* unmask RESET flag */
;;;135    	wCNTR|=CNTR_RESETM;
000028  f4406080          ORR      r0,r0,#0x400
;;;136    	_SetCNTR(wCNTR);
00002c  4c2c              LDR      r4,|L5.224|
00002e  6020              STR      r0,[r4,#0]
;;;137    	
;;;138    	/*apply FRES */
;;;139    	wCNTR|=CNTR_FRES;
000030  f0400001          ORR      r0,r0,#1
;;;140    	_SetCNTR(wCNTR);
000034  6020              STR      r0,[r4,#0]
;;;141    	
;;;142    	/*clear FRES*/
;;;143    	wCNTR&=~CNTR_FRES;
000036  f0200001          BIC      r0,r0,#1
;;;144    	_SetCNTR(wCNTR);
00003a  6020              STR      r0,[r4,#0]
;;;145    	
;;;146    	/*poll for RESET flag in ISTR*/
;;;147    	while((_GetISTR()&ISTR_RESET) == 0);
00003c  bf00              NOP      
                  |L5.62|
00003e  4c28              LDR      r4,|L5.224|
000040  1d24              ADDS     r4,r4,#4
000042  6824              LDR      r4,[r4,#0]
000044  f4146f80          TST      r4,#0x400
000048  d0f9              BEQ      |L5.62|
;;;148    	
;;;149    	/* clear RESET flag in ISTR */
;;;150    	_SetISTR((uint16_t)CLR_RESET);
00004a  f64f34ff          MOV      r4,#0xfbff
00004e  4d24              LDR      r5,|L5.224|
000050  1d2d              ADDS     r5,r5,#4
000052  602c              STR      r4,[r5,#0]
;;;151    	
;;;152    	/*restore Enpoints*/
;;;153    	for (i=0;i<8;i++)
000054  2100              MOVS     r1,#0
000056  e008              B        |L5.106|
                  |L5.88|
;;;154    	_SetENDPOINT(i, EP[i]);
000058  4c22              LDR      r4,|L5.228|
00005a  f8544021          LDR      r4,[r4,r1,LSL #2]
00005e  b2a4              UXTH     r4,r4
000060  4d1f              LDR      r5,|L5.224|
000062  3d40              SUBS     r5,r5,#0x40
000064  f8454021          STR      r4,[r5,r1,LSL #2]
000068  1c49              ADDS     r1,r1,#1              ;153
                  |L5.106|
00006a  2908              CMP      r1,#8                 ;153
00006c  d3f4              BCC      |L5.88|
;;;155    	
;;;156    	/* Now it is safe to enter macrocell in suspend mode */
;;;157    	wCNTR |= CNTR_FSUSP;
00006e  f0400008          ORR      r0,r0,#8
;;;158    	_SetCNTR(wCNTR);
000072  4c1b              LDR      r4,|L5.224|
000074  6020              STR      r0,[r4,#0]
;;;159    	
;;;160    	/* force low-power mode in the macrocell */
;;;161    	wCNTR = _GetCNTR();
000076  6824              LDR      r4,[r4,#0]
000078  b2a0              UXTH     r0,r4
;;;162    	wCNTR |= CNTR_LPMODE;
00007a  f0400004          ORR      r0,r0,#4
;;;163    	_SetCNTR(wCNTR);
00007e  4c18              LDR      r4,|L5.224|
000080  6020              STR      r0,[r4,#0]
;;;164    	
;;;165    	/*prepare entry in low power mode (STOP mode)*/
;;;166    	/* Select the regulator state in STOP mode*/
;;;167    	savePWR_CR = PWR->CR;
000082  4c19              LDR      r4,|L5.232|
000084  6823              LDR      r3,[r4,#0]
;;;168    	tmpreg = PWR->CR;
000086  6822              LDR      r2,[r4,#0]
;;;169    	/* Clear PDDS and LPDS bits */
;;;170    	tmpreg &= ((uint32_t)0xFFFFFFFC);
000088  f0220203          BIC      r2,r2,#3
;;;171    	/* Set LPDS bit according to PWR_Regulator value */
;;;172    	tmpreg |= PWR_Regulator_LowPower;
00008c  f0420201          ORR      r2,r2,#1
;;;173    	/* Store the new value */
;;;174    	PWR->CR = tmpreg;
000090  6022              STR      r2,[r4,#0]
;;;175    	/* Set SLEEPDEEP bit of Cortex System Control Register */
;;;176    #if defined (STM32F30X) || defined (STM32F37X)
;;;177            SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
;;;178    #else
;;;179            SCB->SCR |= SCB_SCR_SLEEPDEEP;       
000092  4c16              LDR      r4,|L5.236|
000094  6824              LDR      r4,[r4,#0]
000096  f0440404          ORR      r4,r4,#4
00009a  4d14              LDR      r5,|L5.236|
00009c  602c              STR      r4,[r5,#0]
;;;180    #endif
;;;181    	
;;;182    	/* enter system in STOP mode, only when wakeup flag in not set */
;;;183    	if((_GetISTR()&ISTR_WKUP)==0)
00009e  4c10              LDR      r4,|L5.224|
0000a0  1d24              ADDS     r4,r4,#4
0000a2  6824              LDR      r4,[r4,#0]
0000a4  f4145f80          TST      r4,#0x1000
0000a8  d105              BNE      |L5.182|
;;;184    	{
;;;185    		//__WFI();
;;;186    		/* Reset SLEEPDEEP bit of Cortex System Control Register */
;;;187    #if defined (STM32F30X) || defined (STM32F37X)
;;;188                    SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk); 
;;;189    #else
;;;190                    SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP); 
0000aa  462c              MOV      r4,r5
0000ac  6824              LDR      r4,[r4,#0]
0000ae  f0240404          BIC      r4,r4,#4
0000b2  602c              STR      r4,[r5,#0]
0000b4  e013              B        |L5.222|
                  |L5.182|
;;;191    #endif
;;;192    	}
;;;193    	else
;;;194    	{
;;;195    		/* Clear Wakeup flag */
;;;196    		_SetISTR(CLR_WKUP);
0000b6  f64e74ff          MOV      r4,#0xefff
0000ba  4d09              LDR      r5,|L5.224|
0000bc  1d2d              ADDS     r5,r5,#4
0000be  602c              STR      r4,[r5,#0]
;;;197    		/* clear FSUSP to abort entry in suspend mode  */
;;;198            wCNTR = _GetCNTR();
0000c0  1f2c              SUBS     r4,r5,#4
0000c2  6824              LDR      r4,[r4,#0]
0000c4  b2a0              UXTH     r0,r4
;;;199            wCNTR&=~CNTR_FSUSP;
0000c6  f0200008          BIC      r0,r0,#8
;;;200            _SetCNTR(wCNTR);
0000ca  1f2c              SUBS     r4,r5,#4
0000cc  6020              STR      r0,[r4,#0]
;;;201    		
;;;202    		/*restore sleep mode configuration */ 
;;;203    		/* restore Power regulator config in sleep mode*/
;;;204    		PWR->CR = savePWR_CR;
0000ce  4c06              LDR      r4,|L5.232|
0000d0  6023              STR      r3,[r4,#0]
;;;205    		
;;;206    		/* Reset SLEEPDEEP bit of Cortex System Control Register */
;;;207    #if defined (STM32F30X) || defined (STM32F37X)		
;;;208                    SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);
;;;209    #else
;;;210                    SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP);
0000d2  4c06              LDR      r4,|L5.236|
0000d4  6824              LDR      r4,[r4,#0]
0000d6  f0240404          BIC      r4,r4,#4
0000da  4d04              LDR      r5,|L5.236|
0000dc  602c              STR      r4,[r5,#0]
                  |L5.222|
;;;211    #endif
;;;212        }
;;;213    }
0000de  bd30              POP      {r4,r5,pc}
;;;214    
                          ENDP

                  |L5.224|
                          DCD      0x40005c40
                  |L5.228|
                          DCD      ||EP||
                  |L5.232|
                          DCD      0x40007000
                  |L5.236|
                          DCD      0xe000ed10

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  ||EP||
                          %        32

                          AREA ||.data||, DATA, ALIGN=2

                  bDeviceState
                          DCD      0x00000000
                  fSuspendEnabled
000004  01000000          DCB      0x01,0x00,0x00,0x00
                  remotewakeupon
                          DCD      0x00000000
                  ResumeS
00000c  0000              DCB      0x00,0x00
