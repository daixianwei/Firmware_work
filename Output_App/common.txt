; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\Output_App\common.o --asm_dir=..\Output_App\ --list_dir=..\Output_App\ --depend=..\Output_App\common.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=870 -I.\System\CM3 -I.\System\FWlib\inc -I.\System\Startup -I.\ISR -I.\Main -I.\Management\DisplayDriver -I.\Management\HumanInput -I.\Management\Interface -I.\Management\RotationMotor -I.\Management\ScanMotor -I.\Management\Common_CRC -I.\Management\QRCode -I.\Management\SystemManage_RTC -I.\Management\SignalProcess_Sample -I.\USB -I.\USB\comm -I.\USB\lib -I.\USB\src -I.\USB\USB_Communication -ID:\Keil4.0\ARM\RV31\Inc -ID:\Keil4.0\ARM\CMSIS\Include -ID:\Keil4.0\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DUSE_STM3210E_EVAL -W --omf_browse=..\Output_App\common.crf Management\Common_CRC\Common.c]
                          THUMB

                          AREA ||i.Calc4BitsCRC||, CODE, READONLY, ALIGN=2

                  Calc4BitsCRC PROC
;;;26     /******************************************************************************/
;;;27     static uint16 Calc4BitsCRC(uint8 value, uint16 remainder)
000000  4602              MOV      r2,r0
;;;28     {
;;;29         uint8 tableIndex;
;;;30         /* Divide the value by polynomial, via the 4bit CRC table. */
;;;31         tableIndex = ((value) & CRC_BIT4_MASK) ^ ((remainder) >> (CRC_BIT_WIDTH
000002  f002000f          AND      r0,r2,#0xf
000006  ea803321          EOR      r3,r0,r1,ASR #12
;;;32         				- CRC_BIT4_SHIFT));
;;;33         remainder = (crcTable)[tableIndex] ^ (remainder << CRC_BIT4_SHIFT);
00000a  4804              LDR      r0,|L1.28|
00000c  f8300013          LDRH     r0,[r0,r3,LSL #1]
000010  ea801001          EOR      r0,r0,r1,LSL #4
000014  b281              UXTH     r1,r0
;;;34         return remainder;
000016  4608              MOV      r0,r1
;;;35     }
000018  4770              BX       lr
;;;36     
                          ENDP

00001a  0000              DCW      0x0000
                  |L1.28|
                          DCD      crcTable

                          AREA ||i.Common_CalculateCRC||, CODE, READONLY, ALIGN=1

                  Common_CalculateCRC PROC
;;;37     /******************************************************************************/
;;;38     uint16 Common_CalculateCRC(uint8 * message,uint32 length,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;39     		uint16 remainder, uint16 xorMask)
;;;40     {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4614              MOV      r4,r2
00000a  4699              MOV      r9,r3
;;;41         uint32 messageIndex;
;;;42         uint8 byteValue;
;;;43     
;;;44         /* don't make count down cycle! CRC will be different! */
;;;45         for(messageIndex = 0; messageIndex < length; messageIndex++)
00000c  2500              MOVS     r5,#0
00000e  e00b              B        |L2.40|
                  |L2.16|
;;;46         {
;;;47             byteValue = message[messageIndex];
000010  5d7e              LDRB     r6,[r7,r5]
;;;48             remainder = Calc4BitsCRC(byteValue>>CRC_BIT4_SHIFT, remainder);
000012  1130              ASRS     r0,r6,#4
000014  4621              MOV      r1,r4
000016  f7fffffe          BL       Calc4BitsCRC
00001a  4604              MOV      r4,r0
;;;49             remainder = Calc4BitsCRC(byteValue, remainder);
00001c  4621              MOV      r1,r4
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       Calc4BitsCRC
000024  4604              MOV      r4,r0
000026  1c6d              ADDS     r5,r5,#1              ;45
                  |L2.40|
000028  4545              CMP      r5,r8                 ;45
00002a  d3f1              BCC      |L2.16|
;;;50         }
;;;51     
;;;52         /* Perform the final remainder CRC. */
;;;53         return remainder ^ xorMask;
00002c  ea840009          EOR      r0,r4,r9
;;;54     }
000030  e8bd87f0          POP      {r4-r10,pc}
;;;55     
                          ENDP


                          AREA ||i.Common_EXTI_Init||, CODE, READONLY, ALIGN=1

                  Common_EXTI_Init PROC
;;;55     
;;;56     void Common_EXTI_Init(GPIO_TypeDef* port, uint16 pin,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;57     		uint8 portSrc, uint8 pinSrc, uint32 extiLine, EXTITrigger_TypeDef type,
;;;58     		FunctionalState defaultCmd, uint8 irqCh, uint8 prePri, uint8 subPri)
;;;59     {
000004  b085              SUB      sp,sp,#0x14
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
00000c  af12              ADD      r7,sp,#0x48
00000e  e8970f80          LDM      r7,{r7-r11}
;;;60     	GPIO_InitTypeDef  GPIO_InitStructure;
;;;61     	EXTI_InitTypeDef EXTI_InitStructure;
;;;62     	NVIC_InitTypeDef NVIC_InitStructure;
;;;63     
;;;64     	GPIO_InitStructure.GPIO_Pin = pin;
000012  f8ad4010          STRH     r4,[sp,#0x10]
;;;65     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000016  2003              MOVS     r0,#3
000018  f88d0012          STRB     r0,[sp,#0x12]
;;;66     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
00001c  2048              MOVS     r0,#0x48
00001e  f88d0013          STRB     r0,[sp,#0x13]
;;;67     	GPIO_Init(port, &GPIO_InitStructure);
000022  a904              ADD      r1,sp,#0x10
000024  9805              LDR      r0,[sp,#0x14]
000026  f7fffffe          BL       GPIO_Init
;;;68     
;;;69     	GPIO_EXTILineConfig(portSrc, pinSrc);
00002a  4631              MOV      r1,r6
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       GPIO_EXTILineConfig
;;;70     
;;;71     	EXTI_InitStructure.EXTI_Line = extiLine;
000032  9702              STR      r7,[sp,#8]
;;;72     	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
000034  2000              MOVS     r0,#0
000036  f88d000c          STRB     r0,[sp,#0xc]
;;;73     	EXTI_InitStructure.EXTI_Trigger = type;
00003a  f88d800d          STRB     r8,[sp,#0xd]
;;;74     	EXTI_InitStructure.EXTI_LineCmd = defaultCmd;
00003e  f88d900e          STRB     r9,[sp,#0xe]
;;;75     	EXTI_Init(&EXTI_InitStructure);
000042  a802              ADD      r0,sp,#8
000044  f7fffffe          BL       EXTI_Init
;;;76     
;;;77     	EXTI_ClearITPendingBit(extiLine);
000048  4638              MOV      r0,r7
00004a  f7fffffe          BL       EXTI_ClearITPendingBit
;;;78     
;;;79     	NVIC_InitStructure.NVIC_IRQChannel = irqCh;
00004e  f88da004          STRB     r10,[sp,#4]
;;;80     	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = prePri;
000052  f88db005          STRB     r11,[sp,#5]
;;;81     	NVIC_InitStructure.NVIC_IRQChannelSubPriority = subPri;
000056  9817              LDR      r0,[sp,#0x5c]
000058  f88d0006          STRB     r0,[sp,#6]
;;;82     	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00005c  2001              MOVS     r0,#1
00005e  f88d0007          STRB     r0,[sp,#7]
;;;83     	NVIC_Init(&NVIC_InitStructure);
000062  a801              ADD      r0,sp,#4
000064  f7fffffe          BL       NVIC_Init
;;;84     }
000068  b009              ADD      sp,sp,#0x24
00006a  e8bd8ff0          POP      {r4-r11,pc}
;;;85     
                          ENDP


                          AREA ||i.SoftReset||, CODE, READONLY, ALIGN=2

                  SoftReset PROC
;;;86     /******************************************************************************/
;;;87     void SoftReset(void)
000000  2001              MOVS     r0,#1
000002  f3808813          MSR      FAULTMASK,r0
000006  bf00              NOP      
;;;88     {
;;;89     	/* Disable all the interrupts */
;;;90     	__set_FAULTMASK(1);
;;;91     	/* Software reset */
;;;92     	NVIC_SystemReset();
000008  bf00              NOP      
00000a  4807              LDR      r0,|L4.40|
00000c  6800              LDR      r0,[r0,#0]
00000e  f40060e0          AND      r0,r0,#0x700
000012  4906              LDR      r1,|L4.44|
000014  4308              ORRS     r0,r0,r1
000016  1d00              ADDS     r0,r0,#4
000018  4903              LDR      r1,|L4.40|
00001a  6008              STR      r0,[r1,#0]
00001c  f3bf8f40          DSB      #0x0
000020  bf00              NOP      
000022  bf00              NOP      
                  |L4.36|
000024  e7fe              B        |L4.36|
;;;93     }
                          ENDP

000026  0000              DCW      0x0000
                  |L4.40|
                          DCD      0xe000ed0c
                  |L4.44|
                          DCD      0x05fa0000

                          AREA ||.constdata||, DATA, READONLY, ALIGN=1

                  crcTable
000000  00001021          DCW      0x0000,0x1021
000004  20423063          DCW      0x2042,0x3063
000008  408450a5          DCW      0x4084,0x50a5
00000c  60c670e7          DCW      0x60c6,0x70e7
000010  81089129          DCW      0x8108,0x9129
000014  a14ab16b          DCW      0xa14a,0xb16b
000018  c18cd1ad          DCW      0xc18c,0xd1ad
00001c  e1cef1ef          DCW      0xe1ce,0xf1ef
